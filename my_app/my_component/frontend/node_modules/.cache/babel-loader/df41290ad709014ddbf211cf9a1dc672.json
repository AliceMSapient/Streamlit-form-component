{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nvar __require = /* @__PURE__ */(x => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function (x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\nvar __objRest = (source, exclude) => {\n  var target = {};\n\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\n\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\n\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n\n  return getter ? getter.call(obj) : member.get(obj);\n};\n\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\n\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\n\nvar __privateWrapper = (obj, member, setter, getter) => {\n  return {\n    set _(value) {\n      __privateSet(obj, member, value, setter);\n    },\n\n    get _() {\n      return __privateGet(obj, member, getter);\n    }\n\n  };\n};\n\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n\n  return method;\n};\n\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n}; // src/search/constants.ts\n\n\nvar SEARCH_URL = `https://api.mapbox.com/search/v1`;\nvar ENDPOINT_SUGGEST = \"suggest\";\nvar ENDPOINT_RETRIEVE = \"retrieve\";\nvar ENDPOINT_FORWARD = \"forward\";\nvar ENDPOINT_REVERSE = \"reverse\";\nvar SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nvar RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\nvar FORWARD_URL = `${SEARCH_URL}/${ENDPOINT_FORWARD}`;\nvar PERMANENT_FORWARD_URL = `${SEARCH_URL}/permanent/${ENDPOINT_FORWARD}`;\nvar REVERSE_URL = `${SEARCH_URL}/${ENDPOINT_REVERSE}`;\nvar PERMANENT_REVERSE_URL = `${SEARCH_URL}/permanent/${ENDPOINT_REVERSE}`; // src/LngLat.ts\n\nvar LngLat = class {\n  constructor(lng, lat) {\n    if (isNaN(lng) || isNaN(lat)) {\n      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n    }\n\n    this.lng = +lng;\n    this.lat = +lat;\n\n    if (this.lat > 90 || this.lat < -90) {\n      throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n    }\n\n    if (this.lng > 180 || this.lng < -180) {\n      throw new Error(\"Invalid LngLat longitude value: must be between -180 and 180\");\n    }\n  }\n\n  toArray() {\n    return [this.lng, this.lat];\n  }\n\n  toString() {\n    return `LngLat(${this.lng}, ${this.lat})`;\n  }\n\n  static convert(input) {\n    if (input instanceof LngLat) {\n      return new LngLat(input.lng, input.lat);\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLat(Number(input[0]), Number(input[1]));\n    }\n\n    if (!Array.isArray(input) && typeof input == \"object\" && input !== null && (\"lng\" in input || \"lon\" in input) && \"lat\" in input) {\n      return new LngLat(Number(\"lng\" in input ? input.lng : input.lon), Number(input.lat));\n    }\n\n    throw new Error(\"`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n  }\n\n}; // src/LngLatBounds.ts\n\nvar LngLatBounds = class {\n  constructor(sw, ne) {\n    this._sw = LngLat.convert(sw);\n    this._ne = LngLat.convert(ne);\n  }\n\n  getSouthWest() {\n    return this._sw;\n  }\n\n  getNorthEast() {\n    return this._ne;\n  }\n\n  getNorthWest() {\n    return new LngLat(this.getWest(), this.getNorth());\n  }\n\n  getSouthEast() {\n    return new LngLat(this.getEast(), this.getSouth());\n  }\n\n  getWest() {\n    return this._sw.lng;\n  }\n\n  getSouth() {\n    return this._sw.lat;\n  }\n\n  getEast() {\n    return this._ne.lng;\n  }\n\n  getNorth() {\n    return this._ne.lat;\n  }\n\n  toArray() {\n    return [this._sw.toArray(), this._ne.toArray()];\n  }\n\n  toFlatArray() {\n    return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat];\n  }\n\n  toString() {\n    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n  }\n\n  static convert(input) {\n    if (!input) {\n      throw new Error(\"Invalid LngLatBounds convert value: falsy\");\n    }\n\n    if (input instanceof LngLatBounds) {\n      return new LngLatBounds(input.getSouthWest(), input.getNorthEast());\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLatBounds(LngLat.convert(input[0]), LngLat.convert(input[1]));\n    }\n\n    if (Array.isArray(input) && input.length === 4) {\n      return new LngLatBounds(LngLat.convert([input[0], input[1]]), LngLat.convert([input[2], input[3]]));\n    }\n\n    throw new Error(\"`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]\");\n  }\n\n}; // src/utils/uuid.ts\n\nimport getRandomValuesPolyfill from \"polyfill-crypto.getrandomvalues\";\n\nfunction getRandomValues(arr) {\n  if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.getRandomValues !== \"function\") {\n    return getRandomValuesPolyfill(arr);\n  }\n\n  return globalThis.crypto.getRandomValues(arr);\n}\n\nfunction bytesToUuid(bytes) {\n  const bits = [...bytes].map(bit => {\n    const s = bit.toString(16);\n    return bit < 16 ? \"0\" + s : s;\n  });\n  return [...bits.slice(0, 4), \"-\", ...bits.slice(4, 6), \"-\", ...bits.slice(6, 8), \"-\", ...bits.slice(8, 10), \"-\", ...bits.slice(10, 16)].join(\"\");\n}\n\nfunction generateUUID() {\n  const rnds = getRandomValues(new Uint8Array(16));\n  rnds[6] = rnds[6] & 15 | 64;\n  rnds[8] = rnds[8] & 63 | 128;\n  return bytesToUuid(rnds);\n} // src/SessionToken.ts\n\n\nvar SESSION_TOKEN_EXPIRY = 60 * 60 * 1e3;\nvar SessionToken = class {\n  constructor(id) {\n    let ts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();\n    this.id = id != null ? id : generateUUID();\n    this.ts = ts;\n  }\n\n  toString() {\n    return this.id;\n  }\n\n  static convert(token) {\n    return new SessionToken(token instanceof SessionToken ? token.id : token.toString(), token instanceof SessionToken ? token.ts : Date.now());\n  }\n\n  isExpired() {\n    return Date.now() - this.ts > SESSION_TOKEN_EXPIRY;\n  }\n\n}; // src/MapboxError.ts\n\nvar UNKNOWN_ERROR = \"Unknown error\";\nvar MapboxError = class extends Error {\n  constructor(json, statusCode) {\n    super(String(json.message || json.error || UNKNOWN_ERROR));\n    this.name = \"MapboxError\";\n    this.statusCode = statusCode;\n  }\n\n  toString() {\n    return `${this.name} (${this.statusCode}): ${this.message}`;\n  }\n\n};\n\nfunction handleNonOkRes(res) {\n  return __async(this, null, function* () {\n    if (!res.ok) {\n      const json = yield res.json();\n      throw new MapboxError(json, res.status);\n    }\n  });\n} // src/fetch.ts\n\n\nvar _fetchImpl = globalThis.fetch;\nvar _abortControllerImpl = globalThis.AbortController;\n\nfunction polyfillFetch(_ref) {\n  let {\n    fetch,\n    AbortController\n  } = _ref;\n  let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!fetch) {\n    throw new Error(\"Fetch implementation must include implementations of `fetch`.\");\n  }\n\n  if (_fetchImpl && !force) {\n    return;\n  }\n\n  _fetchImpl = fetch;\n  _abortControllerImpl = AbortController;\n}\n\nfunction getFetch() {\n  if (!_fetchImpl) {\n    throw new Error(\"Fetch implementation not found. Please use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.\");\n  }\n\n  return {\n    fetch: _fetchImpl,\n    AbortController: _abortControllerImpl\n  };\n}\n\nfunction nodeRequire(fn, str) {\n  return fn(str);\n}\n\nif (!_fetchImpl && true && process.versions.node) {\n  const {\n    default: fetch\n  } = nodeRequire(__require, \"node-fetch\");\n  const AbortController = nodeRequire(__require, \"abort-controller\");\n  polyfillFetch({\n    fetch,\n    AbortController\n  });\n} // src/utils/queryParams.ts\n\n\nfunction queryParams() {\n  const params = [];\n\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  for (const obj of objects) {\n    if (!obj) continue;\n    const entries = Object.entries(obj);\n\n    for (const [key, value] of entries) {\n      if (value == null) continue;\n      params.push(`${key}=${encodeURIComponent(String(value))}`);\n    }\n  }\n\n  return params.join(\"&\");\n} // src/search/MapboxSearch.ts\n\n\nvar _getQueryParams, getQueryParams_fn, _getFetchInfo, getFetchInfo_fn;\n\nvar _MapboxSearch = class {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    __privateAdd(this, _getQueryParams);\n\n    __privateAdd(this, _getFetchInfo);\n\n    const _a = options,\n          {\n      accessToken\n    } = _a,\n          defaults = __objRest(_a, [\"accessToken\"]);\n\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _MapboxSearch.defaults), defaults);\n  }\n\n  suggest(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n\n      if (!this.accessToken) {\n        throw new Error(\"accessToken is required\");\n      }\n\n      if (!optionsArg || !optionsArg.sessionToken) {\n        throw new Error(\"sessionToken is required\");\n      }\n\n      const {\n        sessionToken,\n        signal\n      } = optionsArg;\n\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n\n      if (options.eta_type && (!options.origin || !options.navigation_profile)) {\n        throw new Error(\"to provide eta estimate: eta, navigation_profile, and origin are required\");\n      }\n\n      if (options.origin && !options.navigation_profile) {\n        throw new Error(\"to provide distance estimate: both navigation_profile and origin are required\");\n      }\n\n      const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n\n  retrieve(suggestion, optionsArg) {\n    return __async(this, null, function* () {\n      if (!suggestion) {\n        throw new Error(\"suggestion is required\");\n      }\n\n      if (!this.accessToken) {\n        throw new Error(\"accessToken is required\");\n      }\n\n      if (!this.canRetrieve(suggestion)) {\n        throw new Error(\"suggestion cannot be retrieved\");\n      }\n\n      if (!optionsArg || !optionsArg.sessionToken) {\n        throw new Error(\"sessionToken is required\");\n      }\n\n      const {\n        sessionToken: sessionTokenLike,\n        signal\n      } = optionsArg;\n      const sessionToken = SessionToken.convert(sessionTokenLike);\n      const url = new URL(RETRIEVE_URL);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        session_token: sessionToken.id\n      });\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), __spreadProps(__spreadValues({}, __privateMethod(this, _getFetchInfo, getFetchInfo_fn).call(this, suggestion)), {\n        signal\n      }));\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n\n  canRetrieve(suggestion) {\n    const action = suggestion.action;\n\n    if (!action) {\n      return false;\n    }\n\n    return action.method === \"POST\" && action.endpoint === ENDPOINT_RETRIEVE;\n  }\n\n  canSuggest(suggestion) {\n    const action = suggestion.action;\n\n    if (!action) {\n      return false;\n    }\n\n    return action.method === \"POST\" && action.endpoint === ENDPOINT_SUGGEST;\n  }\n\n  forward(_0) {\n    return __async(this, arguments, function* (searchText) {\n      let optionsArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n\n      if (!this.accessToken) {\n        throw new Error(\"accessToken is required\");\n      }\n\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n\n      const baseUrl = options.permanent ? PERMANENT_FORWARD_URL : FORWARD_URL;\n      const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal: options.signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n\n  reverse(_0) {\n    return __async(this, arguments, function* (lngLat) {\n      let optionsArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!lngLat) {\n        throw new Error(\"lngLat is required\");\n      }\n\n      if (!this.accessToken) {\n        throw new Error(\"accessToken is required\");\n      }\n\n      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);\n\n      const searchText = typeof lngLat === \"string\" ? lngLat : LngLat.convert(lngLat).toArray().join(\",\");\n      const baseUrl = options.permanent ? PERMANENT_REVERSE_URL : REVERSE_URL;\n      const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n      url.search = queryParams({\n        access_token: this.accessToken,\n        language: options.language,\n        limit: options.limit\n      }, options.types && {\n        types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n      });\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal: options.signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return json;\n    });\n  }\n\n};\n\nvar MapboxSearch = _MapboxSearch;\n_getQueryParams = new WeakSet();\n\ngetQueryParams_fn = function (options) {\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country,\n    limit: options.limit,\n    navigation_profile: options.navigation_profile,\n    eta_type: options.eta_type\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.origin && {\n    origin: typeof options.origin === \"string\" ? options.origin : LngLat.convert(options.origin).toArray().join(\",\")\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  }, options.types && {\n    types: typeof options.types === \"string\" ? options.types : [...options.types].join(\",\")\n  });\n};\n\n_getFetchInfo = new WeakSet();\n\ngetFetchInfo_fn = function (suggestion) {\n  if (!this.canRetrieve(suggestion) && !this.canSuggest(suggestion)) {\n    throw new Error(\"Suggestion cannot be retrieved or suggested\");\n  }\n\n  const action = suggestion.action;\n  const body = JSON.stringify(action.body);\n  return {\n    method: action.method,\n    body,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"Content-Length\": body.length.toString()\n    }\n  };\n};\n\nMapboxSearch.defaults = {\n  language: \"en\"\n}; // src/autofill/constants.ts\n\nvar SEARCH_URL2 = `https://api.mapbox.com/autofill/v1`;\nvar ENDPOINT_SUGGEST2 = \"suggest\";\nvar ENDPOINT_RETRIEVE2 = \"retrieve\";\nvar SUGGEST_URL2 = `${SEARCH_URL2}/${ENDPOINT_SUGGEST2}`;\nvar RETRIEVE_URL2 = `${SEARCH_URL2}/${ENDPOINT_RETRIEVE2}`; // src/autofill/MapboxAutofill.ts\n\nvar _getQueryParams2, getQueryParams_fn2;\n\nvar _MapboxAutofill = class {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    __privateAdd(this, _getQueryParams2);\n\n    const _a = options,\n          {\n      accessToken\n    } = _a,\n          defaults = __objRest(_a, [\"accessToken\"]);\n\n    this.accessToken = accessToken;\n    this.defaults = __spreadValues(__spreadValues({}, _MapboxAutofill.defaults), defaults);\n  }\n\n  suggest(searchText, optionsArg) {\n    return __async(this, null, function* () {\n      if (!searchText) {\n        throw new Error(\"searchText is required\");\n      }\n\n      if (!this.accessToken) {\n        throw new Error(\"accessToken is required\");\n      }\n\n      if (!optionsArg || !optionsArg.sessionToken) {\n        throw new Error(\"sessionToken is required\");\n      }\n\n      const {\n        sessionToken,\n        signal\n      } = optionsArg;\n\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n\n      const url = new URL(`${SUGGEST_URL2}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n      return __spreadProps(__spreadValues({}, json), {\n        suggestions: json.suggestions.map(suggestion => {\n          return __spreadProps(__spreadValues({}, suggestion), {\n            original_search_text: searchText\n          });\n        })\n      });\n    });\n  }\n\n  retrieve(suggestion, optionsArg) {\n    return __async(this, null, function* () {\n      if (!suggestion) {\n        throw new Error(\"suggestion is required\");\n      }\n\n      if (!this.accessToken) {\n        throw new Error(\"accessToken is required\");\n      }\n\n      if (!optionsArg || !optionsArg.sessionToken) {\n        throw new Error(\"sessionToken is required\");\n      }\n\n      const {\n        sessionToken,\n        signal\n      } = optionsArg;\n\n      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {\n        sessionToken\n      });\n\n      const isRichSuggestion = typeof suggestion !== \"string\";\n      const searchText = isRichSuggestion ? suggestion.original_search_text : suggestion;\n      const url = new URL(`${RETRIEVE_URL2}/${encodeURIComponent(searchText)}`);\n      url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);\n      const {\n        fetch\n      } = getFetch();\n      const res = yield fetch(url.toString(), {\n        signal\n      });\n      yield handleNonOkRes(res);\n      const json = yield res.json();\n\n      if (!isRichSuggestion) {\n        return json;\n      }\n\n      return __spreadProps(__spreadValues({}, json), {\n        features: json.features.filter(feature => {\n          return feature.properties.full_address === suggestion.full_address;\n        })\n      });\n    });\n  }\n\n};\n\nvar MapboxAutofill = _MapboxAutofill;\n_getQueryParams2 = new WeakSet();\n\ngetQueryParams_fn2 = function (options) {\n  return queryParams({\n    access_token: this.accessToken,\n    language: options.language,\n    country: options.country,\n    limit: options.limit\n  }, options.sessionToken && {\n    session_token: SessionToken.convert(options.sessionToken).id\n  }, options.proximity && {\n    proximity: typeof options.proximity === \"string\" ? options.proximity : LngLat.convert(options.proximity).toArray().join(\",\")\n  }, options.bbox && {\n    bbox: typeof options.bbox === \"string\" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(\",\")\n  });\n};\n\nMapboxAutofill.defaults = {\n  language: \"en\",\n  proximity: \"ip\"\n}; // src/autofill/types.ts\n\nvar AutofillMatchCodeConfidence = /* @__PURE__ */(AutofillMatchCodeConfidence2 => {\n  AutofillMatchCodeConfidence2[\"exact\"] = \"exact\";\n  AutofillMatchCodeConfidence2[\"high\"] = \"high\";\n  AutofillMatchCodeConfidence2[\"medium\"] = \"medium\";\n  AutofillMatchCodeConfidence2[\"low\"] = \"low\";\n  return AutofillMatchCodeConfidence2;\n})(AutofillMatchCodeConfidence || {}); // src/utils/Evented.ts\n\n\nvar _listeners;\n\nvar Evented = class {\n  constructor() {\n    __privateAdd(this, _listeners, {});\n  }\n\n  addEventListener(type, listener) {\n    const listenersArr = __privateGet(this, _listeners);\n\n    if (!listenersArr[type]) {\n      listenersArr[type] = [];\n    }\n\n    listenersArr[type].push(listener);\n  }\n\n  removeEventListener(type, listener) {\n    const listenersArr = __privateGet(this, _listeners);\n\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n    const index = listeners.indexOf(listener);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  fire(type, arg0) {\n    const listenersArr = __privateGet(this, _listeners);\n\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n\n    for (const listener of listeners) {\n      listener(arg0);\n    }\n  }\n\n};\n_listeners = new WeakMap(); // src/utils/debounce.ts\n\nfunction debounce(func, wait, signalFn) {\n  let timeout = null;\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n\n    const signal = signalFn && signalFn();\n    timeout = setTimeout(() => {\n      timeout = null;\n\n      if (signal == null ? void 0 : signal.aborted) {\n        return;\n      }\n\n      func(...args);\n    }, wait);\n  };\n} // src/SearchSession.ts\n\n\nvar SESSION_TOKEN_NUM = 50;\n\nfunction createAbortController() {\n  const {\n    AbortController\n  } = getFetch();\n  return new AbortController();\n}\n\nvar _persistSessionToken, _sessionToken, _sessionTokenRef, _getSessionTokenForSuggest, getSessionTokenForSuggest_fn, _suggestions, _abort, _suggestDebounce;\n\nvar SearchSession = class extends Evented {\n  constructor(search) {\n    var _this;\n\n    let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    super();\n    _this = this;\n\n    __privateAdd(this, _getSessionTokenForSuggest);\n\n    __privateAdd(this, _persistSessionToken, false);\n\n    __privateAdd(this, _sessionToken, new SessionToken());\n\n    __privateAdd(this, _sessionTokenRef, 0);\n\n    __privateAdd(this, _suggestions, void 0);\n\n    __privateAdd(this, _abort, createAbortController());\n\n    __privateAdd(this, _suggestDebounce, void 0);\n\n    __privateSet(this, _suggestDebounce, debounce(function (_0) {\n      for (var _len3 = arguments.length, _1 = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        _1[_key3 - 1] = arguments[_key3];\n      }\n\n      return __async(_this, [_0, ..._1], function* (searchText) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        __privateGet(this, _abort).abort();\n\n        __privateSet(this, _abort, createAbortController());\n\n        if (!searchText) {\n          __privateSet(this, _suggestions, null);\n\n          this.fire(\"suggest\", __privateGet(this, _suggestions));\n          return;\n        }\n\n        const sessionToken = __privateMethod(this, _getSessionTokenForSuggest, getSessionTokenForSuggest_fn).call(this);\n\n        try {\n          const res = yield this.search.suggest(searchText, __spreadProps(__spreadValues({\n            sessionToken\n          }, options), {\n            signal: __privateGet(this, _abort).signal\n          }));\n\n          __privateSet(this, _suggestions, res);\n\n          this.fire(\"suggest\", res);\n        } catch (err) {\n          if (err.name === \"AbortError\") {\n            return;\n          }\n\n          this.fire(\"suggesterror\", err);\n        }\n      });\n    }, wait, () => __privateGet(this, _abort).signal));\n\n    Object.defineProperties(this, {\n      search: {\n        value: search,\n        writable: false\n      },\n      debounce: {\n        value: wait,\n        writable: false\n      }\n    });\n  }\n\n  get sessionToken() {\n    return __privateGet(this, _sessionToken);\n  }\n\n  set sessionToken(token) {\n    __privateSet(this, _sessionToken, token);\n\n    __privateSet(this, _persistSessionToken, true);\n  }\n\n  get suggestions() {\n    return __privateGet(this, _suggestions);\n  }\n\n  suggest(searchText, options) {\n    __privateGet(this, _suggestDebounce).call(this, searchText, options);\n\n    return new Promise((resolve, reject) => {\n      let suggestFn;\n      let suggestErrorFn;\n\n      suggestFn = res => {\n        this.removeEventListener(\"suggest\", suggestFn);\n        this.removeEventListener(\"suggesterror\", suggestErrorFn);\n        resolve(res);\n      };\n\n      suggestErrorFn = err => {\n        this.removeEventListener(\"suggest\", suggestFn);\n        this.removeEventListener(\"suggesterror\", suggestErrorFn);\n        reject(err);\n      };\n\n      this.addEventListener(\"suggest\", suggestFn);\n      this.addEventListener(\"suggesterror\", suggestErrorFn);\n    });\n  }\n\n  clear() {\n    this.suggest(\"\");\n  }\n\n  retrieve(suggestion, options) {\n    return __async(this, null, function* () {\n      const res = yield this.search.retrieve(suggestion, __spreadValues({\n        sessionToken: __privateGet(this, _sessionToken)\n      }, options));\n\n      if (!__privateGet(this, _persistSessionToken)) {\n        __privateSet(this, _sessionToken, new SessionToken());\n\n        __privateSet(this, _sessionTokenRef, 0);\n      }\n\n      this.fire(\"retrieve\", res);\n      return res;\n    });\n  }\n\n  canRetrieve(suggestion) {\n    if (!this.search.canRetrieve) {\n      return true;\n    }\n\n    return this.search.canRetrieve(suggestion);\n  }\n\n  canSuggest(suggestion) {\n    if (!this.search.canSuggest) {\n      return true;\n    }\n\n    return this.search.canSuggest(suggestion);\n  }\n\n  abort() {\n    __privateGet(this, _abort).abort();\n\n    __privateSet(this, _abort, createAbortController());\n  }\n\n};\n_persistSessionToken = new WeakMap();\n_sessionToken = new WeakMap();\n_sessionTokenRef = new WeakMap();\n_getSessionTokenForSuggest = new WeakSet();\n\ngetSessionTokenForSuggest_fn = function () {\n  if (!__privateGet(this, _persistSessionToken)) {\n    if (__privateGet(this, _sessionToken).isExpired() || __privateGet(this, _sessionTokenRef) >= SESSION_TOKEN_NUM) {\n      __privateSet(this, _sessionToken, new SessionToken());\n\n      __privateSet(this, _sessionTokenRef, 0);\n    }\n  }\n\n  __privateWrapper(this, _sessionTokenRef)._++;\n  return __privateGet(this, _sessionToken);\n};\n\n_suggestions = new WeakMap();\n_abort = new WeakMap();\n_suggestDebounce = new WeakMap(); // src/featureToSuggestion.ts\n\nfunction featureToSuggestion(feature) {\n  const {\n    properties\n  } = feature;\n  return __spreadValues({}, properties);\n}\n\nexport { AutofillMatchCodeConfidence, Evented, LngLat, LngLatBounds, MapboxAutofill, MapboxError, MapboxSearch, SearchSession, SessionToken, featureToSuggestion, polyfillFetch };","map":{"version":3,"mappings":"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","names":["SEARCH_URL","ENDPOINT_SUGGEST","ENDPOINT_RETRIEVE","ENDPOINT_FORWARD","ENDPOINT_REVERSE","SUGGEST_URL","RETRIEVE_URL","FORWARD_URL","PERMANENT_FORWARD_URL","REVERSE_URL","PERMANENT_REVERSE_URL","constructor","lng","lat","isNaN","Error","toArray","toString","input","LngLat","Array","isArray","length","Number","lon","sw","ne","_sw","convert","_ne","getSouthWest","getNorthEast","getNorthWest","getWest","getNorth","getSouthEast","getEast","getSouth","toFlatArray","LngLatBounds","arr","globalThis","crypto","getRandomValues","getRandomValuesPolyfill","bytes","bits","map","bit","s","slice","join","rnds","Uint8Array","bytesToUuid","SESSION_TOKEN_EXPIRY","id","ts","Date","now","generateUUID","token","SessionToken","isExpired","UNKNOWN_ERROR","json","statusCode","String","message","error","name","res","ok","MapboxError","status","_fetchImpl","fetch","_abortControllerImpl","AbortController","force","fn","str","process","versions","node","default","nodeRequire","__require","polyfillFetch","params","objects","obj","entries","Object","key","value","push","encodeURIComponent","options","__privateAdd","_a","accessToken","defaults","__spreadValues","_MapboxSearch","suggest","searchText","optionsArg","sessionToken","signal","__spreadProps","eta_type","origin","navigation_profile","url","URL","search","__privateMethod","_getQueryParams","getQueryParams_fn","getFetch","handleNonOkRes","retrieve","suggestion","canRetrieve","sessionTokenLike","queryParams","access_token","session_token","_getFetchInfo","getFetchInfo_fn","action","method","endpoint","canSuggest","forward","_0","baseUrl","permanent","reverse","lngLat","language","limit","types","country","proximity","bbox","body","JSON","stringify","headers","MapboxSearch","SEARCH_URL2","ENDPOINT_SUGGEST2","ENDPOINT_RETRIEVE2","SUGGEST_URL2","RETRIEVE_URL2","_MapboxAutofill","_getQueryParams2","getQueryParams_fn2","suggestions","original_search_text","isRichSuggestion","features","filter","feature","properties","full_address","MapboxAutofill","AutofillMatchCodeConfidence","AutofillMatchCodeConfidence2","addEventListener","type","listener","listenersArr","__privateGet","_listeners","removeEventListener","listeners","index","indexOf","splice","fire","arg0","func","wait","signalFn","timeout","args","clearTimeout","setTimeout","aborted","SESSION_TOKEN_NUM","Evented","createAbortController","__privateSet","_suggestDebounce","debounce","_1","__async","_abort","abort","_suggestions","_getSessionTokenForSuggest","getSessionTokenForSuggest_fn","err","defineProperties","writable","_sessionToken","_persistSessionToken","Promise","resolve","reject","suggestFn","suggestErrorFn","clear","_sessionTokenRef","__privateWrapper","_"],"sources":["../src/search/constants.ts","../src/LngLat.ts","../src/LngLatBounds.ts","../src/utils/uuid.ts","../src/SessionToken.ts","../src/MapboxError.ts","../src/fetch.ts","../src/utils/queryParams.ts","../src/search/MapboxSearch.ts","../src/autofill/constants.ts","../src/autofill/MapboxAutofill.ts","../src/autofill/types.ts","../src/utils/Evented.ts","../src/utils/debounce.ts","../src/SearchSession.ts","../src/featureToSuggestion.ts"],"sourcesContent":["export const SEARCH_URL = `https://api.mapbox.com/search/v1`;\n\nexport const ENDPOINT_SUGGEST = 'suggest';\nexport const ENDPOINT_RETRIEVE = 'retrieve';\nexport const ENDPOINT_FORWARD = 'forward';\nexport const ENDPOINT_REVERSE = 'reverse';\n\nexport const SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nexport const RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\n\nexport const FORWARD_URL = `${SEARCH_URL}/${ENDPOINT_FORWARD}`;\nexport const PERMANENT_FORWARD_URL = `${SEARCH_URL}/permanent/${ENDPOINT_FORWARD}`;\n\nexport const REVERSE_URL = `${SEARCH_URL}/${ENDPOINT_REVERSE}`;\nexport const PERMANENT_REVERSE_URL = `${SEARCH_URL}/permanent/${ENDPOINT_REVERSE}`;\n","/**\n * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.\n * These coordinates use longitude, latitude coordinate order (as opposed to latitude, longitude)\n * to match the [GeoJSON specification](https://datatracker.ietf.org/doc/html/rfc7946#section-4),\n * which is equivalent to the OGC:CRS84 coordinate reference system.\n *\n * Note that any method that accepts a `LngLat` object as an argument or option\n * can also accept an `Array` of two numbers and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatLike}.\n *\n * @class LngLat\n * @param lng - Longitude, measured in degrees.\n * @param lat - Latitude, measured in degrees.\n * @example\n * ```typescript\n * const ll = new LngLat(-123.9749, 40.7736);\n * console.log(ll.lng); // = -123.9749\n * ```\n */\nexport class LngLat {\n  /**\n   * @name lng\n   * @instance\n   * @memberof LngLat\n   */\n  readonly lng: number;\n  /**\n   * @name lat\n   * @instance\n   * @memberof LngLat\n   */\n  readonly lat: number;\n\n  constructor(lng: number, lat: number) {\n    if (isNaN(lng) || isNaN(lat)) {\n      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n    }\n    this.lng = +lng;\n    this.lat = +lat;\n    if (this.lat > 90 || this.lat < -90) {\n      throw new Error(\n        'Invalid LngLat latitude value: must be between -90 and 90'\n      );\n    }\n    if (this.lng > 180 || this.lng < -180) {\n      throw new Error(\n        'Invalid LngLat longitude value: must be between -180 and 180'\n      );\n    }\n  }\n\n  /**\n   * Returns the coordinates represented as an array of two numbers.\n   *\n   * @returns The coordinates represeted as an array of longitude and latitude.\n   * @example\n   * ```typescript\n   * const ll = new LngLat(-73.9749, 40.7736);\n   * ll.toArray(); // = [-73.9749, 40.7736]\n   * ```\n   */\n  toArray(): [number, number] {\n    return [this.lng, this.lat];\n  }\n\n  /**\n   * Returns the coordinates represent as a string.\n   *\n   * @returns The coordinates represented as a string of the format `'LngLat(lng, lat)'`.\n   * @example\n   * ```typescript\n   * const ll = new LngLat(-73.9749, 40.7736);\n   * ll.toString(); // = \"LngLat(-73.9749, 40.7736)\"\n   * ```\n   */\n  toString(): string {\n    return `LngLat(${this.lng}, ${this.lat})`;\n  }\n\n  /**\n   * Converts an array of two numbers or an object with `lng` and `lat` or `lon` and `lat` properties\n   * to a `LngLat` object.\n   *\n   * If a `LngLat` object is passed in, the function returns a copy.\n   *\n   * @param input - An array of two numbers or object to convert, or a `LngLat` object to return.\n   * @returns A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.\n   * @example\n   * ```typescript\n   * const arr = [-73.9749, 40.7736];\n   * const ll = LngLat.convert(arr);\n   * console.log(ll);   // = LngLat {lng: -73.9749, lat: 40.7736}\n   * ```\n   */\n  static convert(\n    input:\n      | LngLat\n      | { lng: number; lat: number }\n      | { lon: number; lat: number }\n      | [number, number]\n  ): LngLat {\n    // Make a copy if already an LngLat.\n    if (input instanceof LngLat) {\n      return new LngLat(input.lng, input.lat);\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLat(Number(input[0]), Number(input[1]));\n    }\n\n    if (\n      !Array.isArray(input) &&\n      typeof input == 'object' &&\n      input !== null &&\n      ('lng' in input || 'lon' in input) &&\n      'lat' in input\n    ) {\n      return new LngLat(\n        Number('lng' in input ? input.lng : input.lon),\n        Number(input.lat)\n      );\n    }\n\n    throw new Error(\n      '`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]'\n    );\n  }\n}\n\n/**\n * A {@link LngLat} object, an array of two numbers representing longitude and latitude,\n * or an object with `lng` and `lat` or `lon` and `lat` properties.\n *\n * @typedef LngLatLike\n * @type {LngLat | [number, number] | { lng: number, lat: number } | { lon: number, lat: number }}\n * @example\n * ```typescript\n * const v1 = new LngLat(-122.420679, 37.772537);\n * const v2 = [-122.420679, 37.772537];\n * const v3 = {lon: -122.420679, lat: 37.772537};\n * ```\n */\nexport type LngLatLike =\n  | LngLat\n  | { lng: number; lat: number }\n  | { lon: number; lat: number }\n  | [number, number];\n","import { LngLat, LngLatLike } from './LngLat';\n\n/**\n * A `LngLatBounds` object represents a geographical bounding box,\n * defined by its southwest and northeast points in longitude and latitude.\n *\n * Note that any method that accepts a `LngLatBounds` object as an argument or option\n * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatBoundsLike}.\n *\n * @class LngLatBounds\n */\nexport class LngLatBounds {\n  private _ne: LngLat;\n  private _sw: LngLat;\n\n  /**\n   * @param sw - The southwest corner of the bounding box.\n   * @param ne - The northeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const sw = new LngLat(-73.9876, 40.7661);\n   * const ne = new LngLat(-73.9397, 40.8002);\n   * const llb = new LngLatBounds(sw, ne);\n   * ```\n   */\n  constructor(sw: LngLatLike, ne: LngLatLike) {\n    this._sw = LngLat.convert(sw);\n    this._ne = LngLat.convert(ne);\n  }\n\n  /**\n   * Returns the southwest corner of the bounding box.\n   *\n   * @returns The southwest corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouthWest(); // LngLat {lng: -73.9876, lat: 40.7661}\n   * ```\n   */\n  getSouthWest(): LngLat {\n    return this._sw;\n  }\n\n  /**\n   * Returns the northeast corner of the bounding box.\n   *\n   * @returns The northeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorthEast(); // LngLat {lng: -73.9397, lat: 40.8002}\n   * ```\n   */\n  getNorthEast(): LngLat {\n    return this._ne;\n  }\n\n  /**\n   * Returns the northwest corner of the bounding box. This is commonly used\n   * as the 'min' point in the bounding box.\n   *\n   * @returns The northwest corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorthWest(); // LngLat {lng: -73.9876, lat: 40.8002}\n   * ```\n   */\n  getNorthWest(): LngLat {\n    return new LngLat(this.getWest(), this.getNorth());\n  }\n\n  /**\n   * Returns the southeast corner of the bounding box. This is commonly used\n   * as the 'max' point in the bounding box.\n   *\n   * @returns The southeast corner of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouthEast(); // LngLat {lng: -73.9397, lat: 40.7661}\n   * ```\n   */\n  getSouthEast(): LngLat {\n    return new LngLat(this.getEast(), this.getSouth());\n  }\n\n  /**\n   * Returns the west edge of the bounding box.\n   *\n   * @returns The west edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getWest(); // -73.9876\n   * ```\n   */\n  getWest(): number {\n    return this._sw.lng;\n  }\n\n  /**\n   * Returns the south edge of the bounding box.\n   *\n   * @returns The south edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getSouth(); // 40.7661\n   * ```\n   */\n  getSouth(): number {\n    return this._sw.lat;\n  }\n\n  /**\n   * Returns the east edge of the bounding box.\n   *\n   * @returns The east edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getEast(); // -73.9397\n   * ```\n   */\n  getEast(): number {\n    return this._ne.lng;\n  }\n\n  /**\n   * Returns the north edge of the bounding box.\n   *\n   * @returns The north edge of the bounding box.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.getNorth(); // 40.8002\n   * ```\n   */\n  getNorth(): number {\n    return this._ne.lat;\n  }\n\n  /**\n   * Returns the bounding box represented as an array.\n   *\n   * @returns The bounding box represented as an array, consisting of the\n   *   southwest and northeast coordinates of the bounding represented as arrays of numbers.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]\n   * ```\n   */\n  toArray(): [[number, number], [number, number]] {\n    return [this._sw.toArray(), this._ne.toArray()];\n  }\n\n  /**\n   * Returns the bounding box represented as a flattened array.\n   *\n   * @returns The bounding box represented as an array of numbers in [west, south, east, north] order.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toFlatArray(); // = [-73.9876, 40.7661, -73.9397, 40.8002]\n   * ```\n   */\n  toFlatArray(): [number, number, number, number] {\n    return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat];\n  }\n\n  /**\n   * Return the bounding box represented as a string.\n   *\n   * @returns The bounding box represents as a string of the format\n   *   `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.\n   * @example\n   * ```typescript\n   * const llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n   * llb.toString(); // = \"LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))\"\n   * ```\n   */\n  toString(): string {\n    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n  }\n\n  /**\n   * Converts an array to a `LngLatBounds` object.\n   *\n   * If a `LngLatBounds` object is passed in, the function returns a copy.\n   *\n   * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.\n   *\n   * @param input - An array of two coordinates to convert, or a `LngLatBounds` object to return.\n   * @returns A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.\n   * @example\n   * ```typescript\n   * const arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n   * const llb = LngLatBounds.convert(arr);\n   * console.log(llb);   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}\n   * ```\n   */\n  static convert(\n    input:\n      | LngLatBounds\n      | [LngLatLike, LngLatLike]\n      | [number, number, number, number]\n  ): LngLatBounds {\n    if (!input) {\n      throw new Error('Invalid LngLatBounds convert value: falsy');\n    }\n\n    // Make a copy if already an LngLatBounds.\n    if (input instanceof LngLatBounds) {\n      return new LngLatBounds(input.getSouthWest(), input.getNorthEast());\n    }\n\n    if (Array.isArray(input) && input.length === 2) {\n      return new LngLatBounds(\n        LngLat.convert(input[0]),\n        LngLat.convert(input[1])\n      );\n    }\n\n    if (Array.isArray(input) && input.length === 4) {\n      return new LngLatBounds(\n        LngLat.convert([input[0], input[1]]),\n        LngLat.convert([input[2], input[3]])\n      );\n    }\n\n    throw new Error(\n      '`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]'\n    );\n  }\n}\n\n/**\n * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,\n * or an array of numbers in [west, south, east, north] order.\n *\n * @typedef LngLatBoundsLike\n * @type {LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number]}\n * @example\n * ```typescript\n * const v1 = new LngLatBounds(\n *   new LngLat(-73.9876, 40.7661),\n *   new LngLat(-73.9397, 40.8002)\n * );\n * const v2 = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n * const v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n * ```\n */\nexport type LngLatBoundsLike =\n  | LngLatBounds\n  | [LngLatLike, LngLatLike]\n  | [number, number, number, number];\n","import getRandomValuesPolyfill from 'polyfill-crypto.getrandomvalues';\n\n/**\n * `getRandomValues` is supported on all browsers and Node.js 15+.\n *\n * If our target is **not** one of these platforms, use a semi-secure polyfill.\n *\n * IMPORTANT: THIS IS NOT CRYPTO-GRAPHICALLY SECURE!\n *\n * Since we're using this to generate a random UUID, essentially as an SKU,\n * we don't need to worry about the randomness of the values as much.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\n * @see https://github.com/uuidjs/uuid/issues/416\n */\nfunction getRandomValues<T extends ArrayBufferView | null>(arr: T): T {\n  if (\n    typeof globalThis.crypto === 'undefined' ||\n    typeof globalThis.crypto.getRandomValues !== 'function'\n  ) {\n    return getRandomValuesPolyfill(arr);\n  }\n\n  return globalThis.crypto.getRandomValues(arr);\n}\n\n// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\n\n/**\n * Converts the byte array to a UUID string\n * @param bytes - Used to convert Byte to Hex\n */\nexport function bytesToUuid(bytes: number[] | Uint8Array): string {\n  const bits = [...bytes].map((bit) => {\n    const s = bit.toString(16);\n    return bit < 0x10 ? '0' + s : s;\n  });\n  return [\n    ...bits.slice(0, 4),\n    '-',\n    ...bits.slice(4, 6),\n    '-',\n    ...bits.slice(6, 8),\n    '-',\n    ...bits.slice(8, 10),\n    '-',\n    ...bits.slice(10, 16)\n  ].join('');\n}\n\nconst UUID_RE =\n  /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\n/**\n * Validates the UUID v4.\n * @param id - UUID value.\n */\nexport function validateUUID(id: string): boolean {\n  return UUID_RE.test(id);\n}\n\n/** Generates a RFC4122 v4 UUID (pseudo-randomly-based) */\nexport function generateUUID(): string {\n  const rnds = getRandomValues(new Uint8Array(16));\n\n  rnds[6] = (rnds[6] & 0x0f) | 0x40; // Version 4\n  rnds[8] = (rnds[8] & 0x3f) | 0x80; // Variant 10\n\n  return bytesToUuid(rnds);\n}\n","import { generateUUID } from './utils/uuid';\n\nconst SESSION_TOKEN_EXPIRY = 60 * 60 * 1000; // 60 minutes\n\n/**\n * A `SessionToken` object is a unique identifier that groups together `suggest` / `retrieve` calls as part of the\n * [Mapbox Search API](https://docs.mapbox.com/api/search/search/#retrieve-a-suggestion).\n *\n * Session tokens are used for [billing](https://docs.mapbox.com/api/search/search/#search-api-pricing) and\n * customer-accessible analytics.\n *\n * A [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)) value is recommended,\n * and is generated if an `id` is not provided.\n *\n * Note that any method that accepts a `SessionToken` object as an argument or option\n * can also accept a unique `string` and will perform an implicit conversion.\n * This flexible type is documented as {@link SessionTokenLike}.\n *\n * @name SessionToken\n * @example\n * ```typescript\n * const token = new SessionToken();\n * console.log(token.id); // = I am a UUIDv4 value!\n * ```\n */\nexport class SessionToken {\n  /**\n   * The session token in string format.\n   */\n  readonly id: string;\n  /**\n   * Returns the timestamp of when the session token was initialized.\n   */\n  readonly ts: number;\n\n  constructor(id?: string, ts: number = Date.now()) {\n    this.id = id ?? generateUUID();\n    this.ts = ts;\n  }\n\n  /**\n   * Returns the session token in string format.\n   *\n   * This is the same as calling `token.id`, and is okay to be used for serialization.\n   */\n  toString(): string {\n    return this.id;\n  }\n\n  /**\n   * Converts a string to a `SessionToken` object.\n   *\n   * If a `SessionToken` object is passed in, the function returns a copy.\n   */\n  static convert(token: SessionToken | string): SessionToken {\n    return new SessionToken(\n      token instanceof SessionToken ? token.id : token.toString(),\n      token instanceof SessionToken ? token.ts : Date.now()\n    );\n  }\n\n  /**\n   * Returns `true` if the session token has expired (expired after 60 minutes).\n   */\n  isExpired(): boolean {\n    return Date.now() - this.ts > SESSION_TOKEN_EXPIRY;\n  }\n}\n\n/**\n * A {@link SessionToken} object or string representing a Mapbox Search API session token.\n *\n * It's recommended this value is a [UUIDv4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)) value.\n *\n * @typedef SessionTokenLike\n * @type {SessionToken | string}\n * @example\n * const v1 = new SessionToken();\n * const v2 = new SessionToken('f06e7531-6373-4d5a-8614-b6f313488050');\n * const v3 = 'f06e7531-6373-4d5a-8614-b6f313488050';\n */\nexport type SessionTokenLike = string | SessionToken;\n","export const UNKNOWN_ERROR = 'Unknown error';\n\n/**\n * Thrown from Search JS Core functions when a network request fails.\n *\n * See common errors here:\n * - [MapboxSearch](https://docs.mapbox.com/api/search/search/#search-api-errors)\n * - [MapboxAutofill](https://docs.mapbox.com/api/search/geocoding/#geocoding-api-errors)\n */\nexport class MapboxError extends Error {\n  readonly statusCode: number;\n\n  constructor(json: Record<string, unknown>, statusCode: number) {\n    super(String(json.message || json.error || UNKNOWN_ERROR));\n    this.name = 'MapboxError';\n    this.statusCode = statusCode;\n  }\n\n  /**\n   * Modified Error toString() method to include the status code.\n   */\n  toString(): string {\n    return `${this.name} (${this.statusCode}): ${this.message}`;\n  }\n}\n\n/**\n * Utility function to see if the result is \"ok\" (in 200 range).\n *\n * If not, throw a {@link MapboxError} filled out by the\n * [JSON error format](https://docs.mapbox.com/api/search/search/#search-api-errors).\n */\nexport async function handleNonOkRes(res: Response): Promise<void> {\n  if (!res.ok) {\n    const json = await res.json();\n    throw new MapboxError(json, res.status);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// GLOBALS\nlet _fetchImpl: typeof fetch = globalThis.fetch;\nlet _abortControllerImpl: typeof AbortController = globalThis.AbortController;\n\ninterface FetchImplementation {\n  fetch: typeof fetch;\n  AbortController: typeof AbortController;\n}\n\n/**\n * Polyfills {@link fetch} implementation used in Search JS Core.\n *\n * If a `fetch` implementation is already available, the polyfill will be\n * silently ignored.\n *\n * Search JS Core will automatically use `node-fetch` if running in Node.js,\n * making this function unnecessary for most use cases.\n *\n * @param opts Options for the polyfill.\n * @param {fetch} opts.fetch Required. A custom `fetch` implementation.\n * @param {AbortController} opts.AbortController Required. A custom `AbortController` implementation.\n * @param {boolean} force If `true`, the polyfill will be forced to load. Otherwise, it will only load if `fetch` is not available.\n */\nexport function polyfillFetch(\n  { fetch, AbortController }: FetchImplementation,\n  force = false\n): void {\n  if (!fetch) {\n    throw new Error(\n      'Fetch implementation must include implementations of `fetch`.'\n    );\n  }\n\n  if (_fetchImpl && !force) {\n    return;\n  }\n  _fetchImpl = fetch;\n  _abortControllerImpl = AbortController;\n}\n\n/**\n * Returns the {@link FetchImplementation} used by Search JS Core.\n */\nexport function getFetch(): FetchImplementation {\n  if (!_fetchImpl) {\n    throw new Error(\n      'Fetch implementation not found. Please use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.'\n    );\n  }\n\n  return {\n    fetch: _fetchImpl,\n    AbortController: _abortControllerImpl\n  };\n}\n\n/**\n * Trick ESBuild here into using Node.js require.\n */\nfunction nodeRequire(fn: typeof require, str: string): any {\n  return fn(str);\n}\n\n/**\n * Check for Node.js environment on launch and import `node-fetch` if necessary.\n * https://github.com/node-fetch/node-fetch#commonjs\n */\nif (!_fetchImpl && typeof 'process' !== 'undefined' && process.versions.node) {\n  // Separate the import statement so bundlers can optimize it out.\n  const { default: fetch } = nodeRequire(require, 'node-fetch');\n  const AbortController = nodeRequire(require, 'abort-controller');\n\n  polyfillFetch({\n    fetch,\n    AbortController\n  });\n}\n","type Primitive = string | number | boolean | null;\n\n/**\n * tl;dr - [classnames](https://www.npmjs.com/package/classnames) for query parameters.\n *\n * Encodes query parameters into a stringified form, good for use with {@link URL#search}.\n * Objects are key-value pairs, and if a falsy object is passed, it will be omitted.\n *\n * Null and undefined values are ignored.\n * Array values are encoded as comma-separated values.\n *\n * @example\n * ```typescript\n * const limit = 0;\n * const offset = null;\n * const params = queryParams(\n *  {\n *    q: 'pizza',\n *    c: null\n *  },\n *  (limit != null) && { limit },\n *  (offset != null) && { offset }\n * );\n * console.log(params); // = 'q=pizza&limit=0'\n * ```\n */\nexport function queryParams<T extends Record<string, Primitive>>(\n  ...objects: (T | false)[]\n): string {\n  const params = [];\n  for (const obj of objects) {\n    if (!obj) continue;\n\n    const entries = Object.entries(obj);\n    for (const [key, value] of entries) {\n      if (value == null) continue;\n      params.push(`${key}=${encodeURIComponent(String(value))}`);\n    }\n  }\n\n  return params.join('&');\n}\n","import {\n  ENDPOINT_RETRIEVE,\n  ENDPOINT_SUGGEST,\n  FORWARD_URL,\n  PERMANENT_FORWARD_URL,\n  PERMANENT_REVERSE_URL,\n  RETRIEVE_URL,\n  REVERSE_URL,\n  SUGGEST_URL\n} from './constants';\nimport {\n  AdministrativeUnitTypes,\n  Suggestion,\n  FeatureSuggestion\n} from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism works in the same way as the [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests\n   * together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef Options\n */\nexport interface Options {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * The number of results to return, up to `10`.\n   */\n  limit: string | number;\n  /**\n   * The navigation routing profile to use for distance/eta calculations.\n   *\n   * For distance calculations, both {@link Options#navigation_profile} and\n   * {@link Options#origin} must be specified.\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  navigation_profile?: 'driving' | 'walking' | 'cycling';\n  /**\n   * The location from which to calculate distance. **This parameter may incur additional latency.**\n   *\n   * When both {@link Options#proximity} and {@link Options#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   *\n   * For distance calculations, both {@link Options#navigation_profile} and\n   * {@link Options#origin} must be specified.\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  origin: string | LngLatLike;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link Options#proximity} and {@link Options#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n  /**\n   * Used to estimate the time of arrival from {@link Options#origin}. **This parameter may incur additional latency.**\n   *\n   * For ETA calculations: {@link Options#navigation_profile},\n   * {@link Options#origin}, and {@link Options#eta_type} must be specified.\n   */\n  eta_type?: 'navigation';\n  /**\n   * Limit results to one or more types of features. If no types are specified, all possible types may be returned.\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#administrative-unit-types\n   */\n  types?: string | Set<AdministrativeUnitTypes>;\n}\n\ninterface PermanentOptions {\n  /**\n   * The permanent endpoints are used for use cases that require storing\n   * position data. If 'true', the permanent endpoints will be used, which are\n   * billed separately.\n   *\n   * If you're interested in using {@link PermanentOptions#permanent}, contact\n   * [Mapbox sales](https://www.mapbox.com/contact/sales/).\n   *\n   * It's important to speak with an Account Manager on the Sales team prior to making requests\n   * with {@link PermanentOptions#permanent} set to `true`, as unsuccessful requests\n   * made by an account that does not have access to the endpoint may be billable.\n   */\n  permanent: boolean;\n}\n\n/**\n * @typedef SuggestionResponse\n */\nexport interface SuggestionResponse {\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned suggestion objects.\n   *\n   * @see {@link Suggestion}\n   */\n  suggestions: Suggestion[];\n}\n\n/**\n * @typedef RetrieveResponse\n */\nexport interface RetrieveResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: FeatureSuggestion[];\n}\n\n/**\n * A `MapboxSearch` object is an application's main entrypoint to the [Mapbox Search API](https://docs.mapbox.com/api/search/search/).\n *\n * `MapboxSearch` is focused on the two-step, interactive search experience. These steps are:\n *   1. {@link MapboxSearch#suggest}: The user enters a search term, and a list of suggested results is returned with\n *      optional data such as: eta, distance calculations, etc.\n *   2. {@link MapboxSearch#retrieve}: The user selects a result from the list of suggested results, and the\n *     corresponding geographic coordinates are returned for displaying on a map or otherwise manipulating.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxSearch`, and\n * other options may be specified either in the constructor or in the {@link MapboxSearch#suggest} call.\n *\n * @class MapboxSearch\n * @param {Options} [options]\n * @param {string} [options.accessToken]\n *\n * @example\n * ```typescript\n * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n *\n * const sessionToken = new SessionToken();\n * const result = await search.suggest('Washington D.C.', { sessionToken });\n * if (result.suggestions.length === 0) return;\n *\n * const suggestion = result.suggestions[0];\n * if (search.canRetrieve(suggestion)) {\n *  const { features } = await search.retrieve(suggestion, { sessionToken });\n *  doSomethingWithCoordinates(features);\n * } else if (search.canSuggest(suggestion)) {\n *   // .. go through suggest flow again ..\n * }\n * ```\n */\nexport class MapboxSearch {\n  static defaults: Partial<Options> = {\n    language: 'en'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link Options}) to be merged into options in the following methods:\n   * - {@link MapboxSearch#suggest}\n   * - {@link MapboxSearch#forward}\n   * - {@link MapboxSearch#reverse}\n   */\n  defaults: Partial<Options>;\n\n  constructor(options: Partial<AccessTokenOptions & Options> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxSearch.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Interactive search} */\n\n  /**\n   * {@link MapboxSearch#suggest} is \"part one\" of the two-step interactive search experience, and includes\n   * useful information such as: {@link Suggestion#feature_name}, {@link Suggestion#description}, and {@link Suggestion#maki}.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link MapboxSearch#retrieve}.\n   *\n   * It may be useful to call {@link MapboxSearch#canRetrieve} before calling this method, as the suggestion may be a reference to\n   * another suggest query. This can also be tested with {@link MapboxSearch#canSuggest}, and further calls to {@link MapboxSearch#suggest}.\n   *\n   * For tracking purposes, it is useful for any follow-up requests based on this suggestion to include same\n   * {@link Suggestion#sessionToken} as the original request.\n   *\n   * If you'd like session tokens to be handled automatically, see {@link SearchSession}.\n   *\n   * @param {string} searchText\n   * @param {Options} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async suggest(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions & Options>\n  ): Promise<SuggestionResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n    if (!this.accessToken) {\n      throw new Error('accessToken is required');\n    }\n    if (!optionsArg || !optionsArg.sessionToken) {\n      throw new Error('sessionToken is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    if (options.eta_type && (!options.origin || !options.navigation_profile)) {\n      throw new Error(\n        'to provide eta estimate: eta, navigation_profile, and origin are required'\n      );\n    }\n    if (options.origin && !options.navigation_profile) {\n      throw new Error(\n        'to provide distance estimate: both navigation_profile and origin are required'\n      );\n    }\n\n    const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as SuggestionResponse;\n    return json;\n  }\n\n  /**\n   * {@link MapboxSearch#retrieve} is \"part two\" of the two-step interactive search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link Suggestion} returned from \"part one,\" {@link MapboxSearch#suggest}.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * feature suggestions should come from the {@link MapboxSearch#forward} method\n   * with {@link PermanentOptions#permanent} enabled.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {any} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async retrieve(\n    suggestion: Suggestion,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions>\n  ): Promise<RetrieveResponse> {\n    if (!suggestion) {\n      throw new Error('suggestion is required');\n    }\n    if (!this.accessToken) {\n      throw new Error('accessToken is required');\n    }\n    if (!this.canRetrieve(suggestion)) {\n      throw new Error('suggestion cannot be retrieved');\n    }\n    if (!optionsArg || !optionsArg.sessionToken) {\n      throw new Error('sessionToken is required');\n    }\n\n    const { sessionToken: sessionTokenLike, signal } = optionsArg;\n\n    const sessionToken = SessionToken.convert(sessionTokenLike);\n\n    const url = new URL(RETRIEVE_URL);\n    url.search = queryParams({\n      access_token: this.accessToken,\n      session_token: sessionToken.id\n    });\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      ...this.#getFetchInfo(suggestion),\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns true if {@link MapboxSearch#retrieve} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) has geographic coordinates\n   * for this suggestion.\n   *\n   * This method is mutually exclusive with {@link MapboxSearch#canSuggest}.\n   */\n  canRetrieve(suggestion: Suggestion): boolean {\n    const action = suggestion.action;\n    if (!action) {\n      return false;\n    }\n\n    return action.method === 'POST' && action.endpoint === ENDPOINT_RETRIEVE;\n  }\n\n  /**\n   * Returns true if {@link MapboxSearch#suggest} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) wants to do another\n   * suggestion search on this result, and does not have geographic coordinates.\n   *\n   * This method is mutually exclusive with {@link MapboxSearch#canRetrieve}.\n   */\n  canSuggest(suggestion: Suggestion): boolean {\n    const action = suggestion.action;\n    if (!action) {\n      return false;\n    }\n\n    return action.method === 'POST' && action.endpoint === ENDPOINT_SUGGEST;\n  }\n\n  /** @section {Programmatic search} */\n\n  /**\n   * {@link MapboxSearch#forward} is our programmatic one-step search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * {@link PermanentOptions#permanent} should be enabled. This requires contacting Mapbox support.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {Options} optionsArg\n   * @param {AbortSignal} [optionsArg.signal]\n   * @param {boolean} [optionsArg.permanent]\n   */\n  async forward(\n    searchText: string,\n    optionsArg: Partial<FetchOptions & Options & PermanentOptions> = {}\n  ): Promise<RetrieveResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n    if (!this.accessToken) {\n      throw new Error('accessToken is required');\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const baseUrl = options.permanent ? PERMANENT_FORWARD_URL : FORWARD_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal: options.signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * {@link MapboxSearch#reverse} allows you to look up a geographic coordinate pair\n   * and returns the feature(s) in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, if the results are to be cached/stored in a customer database,\n   * {@link PermanentOptions#permanent} should be enabled. This requires contacting Mapbox support.\n   *\n   * Otherwise, results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param lngLat - Either a {@link LngLatLike} object or string in 'lng,lat' comma-separated format.\n   * @param {Options} optionsArg\n   * @param {AbortSignal} [optionsArg.signal]\n   * @param {boolean} [optionsArg.permanent]\n   */\n  async reverse(\n    lngLat: string | LngLatLike,\n    optionsArg: Partial<FetchOptions & Options & PermanentOptions> = {}\n  ): Promise<RetrieveResponse> {\n    if (!lngLat) {\n      throw new Error('lngLat is required');\n    }\n    if (!this.accessToken) {\n      throw new Error('accessToken is required');\n    }\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg\n    };\n\n    const searchText =\n      typeof lngLat === 'string'\n        ? lngLat\n        : LngLat.convert(lngLat).toArray().join(',');\n\n    const baseUrl = options.permanent ? PERMANENT_REVERSE_URL : REVERSE_URL;\n    const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);\n    url.search = queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        limit: options.limit\n      },\n      options.types && {\n        types:\n          typeof options.types === 'string'\n            ? options.types\n            : [...options.types].join(',')\n      }\n    );\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal: options.signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as RetrieveResponse;\n    return json;\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxSearch#suggest} and\n   * {@link MapboxSearch#forward}.\n   */\n  #getQueryParams(options: Partial<Options & SessionTokenOptions>): string {\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country,\n        limit: options.limit,\n        navigation_profile: options.navigation_profile,\n        eta_type: options.eta_type\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.origin && {\n        origin:\n          typeof options.origin === 'string'\n            ? options.origin\n            : LngLat.convert(options.origin).toArray().join(',')\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      },\n      options.types && {\n        types:\n          typeof options.types === 'string'\n            ? options.types\n            : [...options.types].join(',')\n      }\n    );\n  }\n\n  /**\n   * Gets a partial fetch request from this suggestion's action.\n   */\n  #getFetchInfo(suggestion: Suggestion): Partial<RequestInit> {\n    if (!this.canRetrieve(suggestion) && !this.canSuggest(suggestion)) {\n      throw new Error('Suggestion cannot be retrieved or suggested');\n    }\n\n    const action = suggestion.action;\n    const body = JSON.stringify(action.body);\n\n    return {\n      method: action.method,\n      body,\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': body.length.toString()\n      }\n    };\n  }\n}\n","export const SEARCH_URL = `https://api.mapbox.com/autofill/v1`;\n\nexport const ENDPOINT_SUGGEST = 'suggest';\nexport const ENDPOINT_RETRIEVE = 'retrieve';\n\nexport const SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;\nexport const RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;\n","import { RETRIEVE_URL, SUGGEST_URL } from './constants';\nimport { AutofillSuggestion, AutofillFeatureSuggestion } from './types';\n\nimport { LngLat, LngLatLike } from '../LngLat';\nimport { LngLatBounds, LngLatBoundsLike } from '../LngLatBounds';\nimport { SessionToken, SessionTokenLike } from '../SessionToken';\n\nimport { handleNonOkRes } from '../MapboxError';\nimport { getFetch } from '../fetch';\nimport { queryParams } from '../utils/queryParams';\n\ninterface AccessTokenOptions {\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n}\n\ninterface FetchOptions {\n  /**\n   * If specified, the connected {@link AbortController} can be used to\n   * abort the current network request(s).\n   *\n   * This mechanism intentionally works in the same way as the\n   * [`fetch` API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#aborting_a_fetch).\n   *\n   * Reference:\n   * https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal#examples\n   */\n  signal?: AbortSignal;\n}\n\ninterface SessionTokenOptions {\n  /**\n   * A customer-provided session token value, which groups a series of requests together for [billing purposes](https://docs.mapbox.com/api/search/search/#search-api-pricing).\n   *\n   * Reference:\n   * https://docs.mapbox.com/api/search/search/#session-based-pricing\n   */\n  sessionToken: SessionTokenLike;\n}\n\n/**\n * @typedef AutofillOptions\n */\nexport interface AutofillOptions {\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) to be returned.\n   *\n   * If not specified, `en` will be used.\n   */\n  language: string;\n  /**\n   * An [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) to be returned.\n   *\n   * If not specified, results will not be filtered by country.\n   */\n  country: string;\n  /**\n   * Limit results to only those contained within the supplied bounding box.\n   */\n  bbox: string | LngLatBoundsLike;\n  /**\n   * The number of results to return, up to `10`.\n   */\n  limit: string | number;\n  /**\n   * Bias the response to favor results that are closer to this location.\n   *\n   * When both {@link AutofillOptions#proximity} and {@link AutofillOptions#origin} are specified, `origin` is interpreted as the\n   * target of a route, while `proximity` indicates the current user location.\n   */\n  proximity: string | LngLatLike;\n}\n\n/**\n * @typedef AutofillSuggestionResponse\n */\nexport interface AutofillSuggestionResponse {\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned suggestion objects.\n   *\n   * @see {@link Suggestion}\n   */\n  suggestions: AutofillSuggestion[];\n}\n\n/**\n * @typedef AutofillRetrieveResponse\n */\nexport interface AutofillRetrieveResponse {\n  type: 'FeatureCollection';\n  /**\n   * The attribution data for results.\n   */\n  attribution?: string;\n  /**\n   * The returned feature objects.\n   *\n   * @see {@link FeatureSuggestion}\n   */\n  features: AutofillFeatureSuggestion[];\n}\n\n/**\n * A `MapboxAutofill` object is an application's main entrypoint to the\n * Mapbox Autofill API. The Mapbox Autofill API is an API similar to {@link MapboxSearch},\n * but targeted towards **address** autocomplete.\n *\n * Only address types are returned by the API.\n *\n * `MapboxAutofill` is focused on the two-step, interactive search experience. These steps are:\n *   1. {@link MapboxAutofill#suggest}: The user enters a search term, and a list of suggested results is returned with\n *     address data.\n *   2. {@link MapboxAutofill#retrieve}: The user selects a result from the list of suggested results, and the\n *     corresponding geographic coordinates are returned.\n *\n * A [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) is required to use `MapboxAutofill`, and\n * other options may be specified either in the constructor or in the {@link MapboxAutofill#suggest} call.\n *\n * @class MapboxAutofill\n * @param {AutofillOptions} [options]\n * @param {string} [options.accessToken]\n */\nexport class MapboxAutofill {\n  static defaults: Partial<AutofillOptions> = {\n    language: 'en',\n    proximity: 'ip'\n  };\n\n  /**\n   * The [Mapbox access token](https://docs.mapbox.com/help/glossary/access-token/) to use for all requests.\n   */\n  accessToken: string;\n\n  /**\n   * Any default options ({@link AutofillOptions}) to be merged into options in the following methods:\n   * - {@link MapboxAutofill#suggest}\n   *\n   * @type {AutofillOptions}\n   */\n  defaults: Partial<AutofillOptions>;\n\n  constructor(options: Partial<AccessTokenOptions & AutofillOptions> = {}) {\n    const { accessToken, ...defaults } = options;\n\n    this.accessToken = accessToken;\n\n    // Assign defaults to this.defaults.\n    this.defaults = {\n      ...MapboxAutofill.defaults,\n      ...defaults\n    };\n  }\n\n  /** @section {Methods} */\n\n  /**\n   * {@link MapboxAutofill#suggest} is \"part one\" of the two-step autofill experience, and includes\n   * autofill information.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link MapboxSearch#retrieve}.\n   *\n   * For tracking purposes, it is useful for any follow-up requests based on this suggestion to include same\n   * {@link Suggestion#sessionToken} as the original request.\n   *\n   * If you'd like session tokens to be handled automatically, see {@link SearchSession}.\n   *\n   * @param {AutofillOptions} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async suggest(\n    searchText: string,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions & AutofillOptions>\n  ): Promise<AutofillSuggestionResponse> {\n    if (!searchText) {\n      throw new Error('searchText is required');\n    }\n    if (!this.accessToken) {\n      throw new Error('accessToken is required');\n    }\n    if (!optionsArg || !optionsArg.sessionToken) {\n      throw new Error('sessionToken is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as AutofillSuggestionResponse;\n\n    // Add 'original_search_text' so we can retrieve.\n    return {\n      ...json,\n      suggestions: json.suggestions.map((suggestion) => {\n        return {\n          ...suggestion,\n          original_search_text: searchText\n        };\n      })\n    };\n  }\n\n  /**\n   * {@link MapboxAutofill#retrieve} is \"part two\" of the two-step autofill experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link AutofillSuggestion} returned from \"part one,\"\n   * {@link MapboxAutofill#suggest}.\n   *\n   * Multiple feature suggestions may be returned from a single address,\n   * for example an address with multiple buildings.\n   *\n   * **Legal terms:**\n   *\n   * Geographic coordinates should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   *\n   * @param {AutofillOptions} optionsArg\n   * @param {SessionTokenLike} optionsArg.sessionToken\n   * @param {AbortSignal} [optionsArg.signal]\n   */\n  async retrieve(\n    suggestion: string | AutofillSuggestion,\n    optionsArg: SessionTokenOptions & Partial<FetchOptions & AutofillOptions>\n  ): Promise<AutofillRetrieveResponse> {\n    if (!suggestion) {\n      throw new Error('suggestion is required');\n    }\n    if (!this.accessToken) {\n      throw new Error('accessToken is required');\n    }\n    if (!optionsArg || !optionsArg.sessionToken) {\n      throw new Error('sessionToken is required');\n    }\n\n    const { sessionToken, signal } = optionsArg;\n\n    const options = {\n      ...this.defaults,\n      ...optionsArg,\n      sessionToken\n    };\n\n    const isRichSuggestion = typeof suggestion !== 'string';\n\n    const searchText = isRichSuggestion\n      ? suggestion.original_search_text\n      : suggestion;\n    const url = new URL(`${RETRIEVE_URL}/${encodeURIComponent(searchText)}`);\n    url.search = this.#getQueryParams(options);\n\n    const { fetch } = getFetch();\n    const res = await fetch(url.toString(), {\n      signal\n    });\n\n    // Throw custom error if status code is not 200.\n    await handleNonOkRes(res);\n\n    const json = (await res.json()) as AutofillRetrieveResponse;\n    if (!isRichSuggestion) {\n      return json;\n    }\n\n    return {\n      ...json,\n      features: json.features.filter((feature) => {\n        return feature.properties.full_address === suggestion.full_address;\n      })\n    };\n  }\n\n  /**\n   * Returns the query parameters used by {@link MapboxSearch#suggest} and\n   * {@link MapboxSearch#forward}.\n   */\n  #getQueryParams(\n    options: Partial<AutofillOptions & SessionTokenOptions>\n  ): string {\n    return queryParams(\n      {\n        access_token: this.accessToken,\n        language: options.language,\n        country: options.country,\n        limit: options.limit\n      },\n      options.sessionToken && {\n        session_token: SessionToken.convert(options.sessionToken).id\n      },\n      options.proximity && {\n        proximity:\n          typeof options.proximity === 'string'\n            ? options.proximity\n            : LngLat.convert(options.proximity).toArray().join(',')\n      },\n      options.bbox && {\n        bbox:\n          typeof options.bbox === 'string'\n            ? options.bbox\n            : LngLatBounds.convert(options.bbox).toFlatArray().join(',')\n      }\n    );\n  }\n}\n","// Type definitions for /suggest endpoint suggestions.\n\nimport { LngLatBoundsLike } from '../LngLatBounds';\n\n/**\n * @typedef AutofillMatchCodeConfidence\n */\nexport enum AutofillMatchCodeConfidence {\n  /**\n   * An exact match.\n   */\n  exact = 'exact',\n  /**\n   * High confidence of a match.\n   */\n  high = 'high',\n  /**\n   * Medium confidence of a match.\n   */\n  medium = 'medium',\n  /**\n   * Low confidence of a match.\n   */\n  low = 'low'\n}\n\n/**\n * An object describing the level of confidence that the given response feature matches the address intended by the request query.\n * Includes boolean flags denoting matches for each address sub-component.\n *\n * @typedef AutofillMatchCode\n */\nexport interface AutofillMatchCode {\n  /**\n   * A measure of confidence that the returned feature suggestion matches the intended address, based on the search text provided.\n   */\n  confidence: AutofillMatchCodeConfidence;\n  /**\n   * True if the confidence value is \"exact\".\n   */\n  exact_match: boolean;\n  /**\n   * True if the house number component was matched.\n   */\n  house_number: boolean;\n  /**\n   * True if the street component was matched.\n   */\n  street: boolean;\n  /**\n   * True if the postcode was matched.\n   */\n  postcode: boolean;\n  /**\n   * True if the place component was matched.\n   */\n  place: boolean;\n  /**\n   * True if the region component was matched.\n   */\n  region?: boolean;\n  /**\n   * True if the locality component was matched.\n   */\n  locality?: boolean;\n}\n\n/**\n * An `AutofillSuggestion` object represents a suggestion\n * result from the Mapbox Autofill API.\n *\n * Suggestion objects are \"part one\" of the two-step interactive autofill experience.\n * Suggestion objects do not include geographic coordinates.\n *\n * To get the coordinates of the result, use {@link MapboxAutofill#retrieve}.\n *\n * For tracking purposes, it is useful for any follow-up requests based on this suggestion to include same\n * {@link SessionToken} as the original request.\n *\n * @typedef AutofillSuggestion\n * @example\n * ```typescript\n * const autofill = new MapboxAutofill({ accessToken: 'pk.my-mapbox-access-token' });\n *\n * const sessionToken = new SessionToken();\n * const result = await search.autofill('Washington D.C.', { sessionToken });\n * if (result.suggestions.length === 0) return;\n *\n * const suggestion = result.suggestions[0];\n * const { features } = await autofill.retrieve(suggestion, { sessionToken });\n * doSomethingWithCoordinates(features);\n * ```\n */\nexport interface AutofillSuggestion {\n  /**\n   * This is added by {@link MapboxAutofill} and is **not** part of the\n   * Autofill API.\n   *\n   * @ignore\n   */\n  original_search_text: string;\n\n  /**\n   * The name of the feature.\n   */\n  feature_name: string;\n  /**\n   * The feature name, as matched by the search algorithm.\n   */\n  matching_name: string;\n  /**\n   * Additional details, such as city and state for addresses.\n   */\n  description: string;\n  /**\n   * The name of the [Maki](https://labs.mapbox.com/maki-icons/) icon associated with the feature.\n   */\n  maki?: string;\n  /**\n   * The [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag) of the feature.\n   */\n  language: string;\n\n  address?: string;\n  /**\n   * The full address of the suggestion.\n   */\n  full_address?: string;\n\n  /**\n   * Address line 1 from the [WHATWG Autocomplete Specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill)\n   */\n  address_line1?: string;\n  /**\n   * Address line 2 from the [WHATWG Autocomplete Specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill)\n   */\n  address_line2?: string;\n  /**\n   * Address line 3 from the [WHATWG Autocomplete Specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill)\n   */\n  address_line3?: string;\n\n  /**\n   * Address level 1 from the [WHATWG Autocomplete Specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill)\n   */\n  address_level1?: string;\n  /**\n   * Address level 2 from the [WHATWG Autocomplete Specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill)\n   */\n  address_level2?: string;\n  /**\n   * Address level 3 from the [WHATWG Autocomplete Specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill)\n   */\n  address_level3?: string;\n\n  /**\n   * Long form country name, for example: \"United States\"\n   */\n  country?: string;\n  /**\n   * Postal code.\n   */\n  postcode?: string;\n\n  /**\n   * Address metadata fields of the feature.\n   *\n   * Includes the short form country name, for example: \"us\". This follows the\n   * [ISO 3166 alpha-2 country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) specification.\n   */\n  metadata: {\n    iso_3166_1: string;\n  };\n\n  /**\n   * A string representing the feature in the requested language, if specified, and its full result hierarchy.\n   */\n  place_name?: string;\n\n  /**\n   * An object describing the level of confidence that the given response feature matches the address intended by the request query.\n   * Includes boolean flags denoting matches for each address sub-component.\n   */\n  match_code: AutofillMatchCode;\n}\n\n/**\n * An `AutofillFeatureSuggestion` object represents [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/)\n * suggestion results from the Mapbox Autofill API.\n *\n * As per the Mapbox Autofill API, this will always be [Point](https://geojson.org/geojson-spec.html#point).\n *\n * @typedef AutofillFeatureSuggestion\n * @example\n * ```typescript\n * const featureSuggestion = {\n *   type: 'Feature',\n *   geometry: {\n *     type: 'Point',\n *     coordinates: [0,0]\n *   },\n *   properties: {\n *     feature_name: 'Washington D.C.',\n *   }\n * };\n * ```\n */\nexport type AutofillFeatureSuggestion = GeoJSON.Feature<\n  GeoJSON.Point,\n  AutofillSuggestion\n> & {\n  /**\n   * A bounding box for the feature. This may be significantly\n   * larger than the geometry.\n   */\n  bbox?: LngLatBoundsLike;\n};\n","/**\n * `Evented` mixes methods into other classes for event capabilities.\n *\n * If you are an end-user, you will most likely use these methods through\n * classes like {@link SearchSession}.\n *\n * For lists of events you can listen for, see API documentation for\n * specific classes.\n *\n * @class Evented\n */\nexport class Evented<T> {\n  #listeners: Partial<{\n    [key in keyof T]: ((arg0: T[key]) => void)[];\n  }> = {};\n\n  /**\n   * Adds a listener to a specified event type.\n   *\n   * @param type - The event type to add a listen for.\n   * @param listener - The function to be called when the event is fired.\n   */\n  addEventListener<K extends keyof T>(\n    type: K,\n    listener: (arg0: T[K]) => void\n  ): void {\n    const listenersArr = this.#listeners;\n\n    // Create listener if doesn't already exist.\n    if (!listenersArr[type]) {\n      listenersArr[type] = [];\n    }\n\n    listenersArr[type].push(listener);\n  }\n\n  /**\n   * Removes a previously registered event listener.\n   *\n   * @param type - The event type to remove listeners for.\n   * @param listener - The listener function to remove.\n   */\n  removeEventListener<K extends keyof T>(\n    type: K,\n    listener: (arg0: T[K]) => void\n  ): void {\n    const listenersArr = this.#listeners;\n\n    // If a type doesn't exist, return early.\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n\n  fire<K extends keyof T>(type: K, arg0: T[K]): void {\n    const listenersArr = this.#listeners;\n\n    // If a type doesn't exist, return early.\n    if (!listenersArr[type]) {\n      return;\n    }\n\n    const listeners = listenersArr[type];\n    for (const listener of listeners) {\n      listener(arg0);\n    }\n  }\n}\n","/**\n * Version of the classic `debounce` function that accepts a `signalFn`\n * argument, which can return an {@link AbortSignal}.\n */\nexport function debounce<F extends (...args: unknown[]) => unknown>(\n  func: F,\n  wait: number,\n  signalFn?: () => AbortSignal\n): F {\n  let timeout = null;\n\n  return ((...args: Parameters<F>) => {\n    if (timeout !== null) {\n      clearTimeout(timeout);\n    }\n\n    const signal = signalFn && signalFn();\n    timeout = setTimeout(() => {\n      timeout = null;\n      if (signal?.aborted) {\n        return;\n      }\n      func(...args);\n    }, wait);\n  }) as F;\n}\n","/* eslint-disable prefer-const */\nimport { SessionToken, SessionTokenLike } from './SessionToken';\n\nimport { getFetch } from './fetch';\n\nimport { Evented } from './utils/Evented';\nimport { debounce } from './utils/debounce';\n\nconst SESSION_TOKEN_NUM = 50;\n\n/**\n * Shortcut function to create a new AbortController from the polyfill.\n */\nfunction createAbortController(): AbortController {\n  const { AbortController } = getFetch();\n  return new AbortController();\n}\n\ninterface EventTypes<SuggestionResponse, RetrieveResponse> {\n  suggest: SuggestionResponse;\n  suggesterror: Error;\n  retrieve: RetrieveResponse;\n}\n\n/**\n * TypeScript magic section: what is this?\n *\n * Despite the name {@link SearchSession}, in Search JS Web we use it to control\n * both {@link MapboxSearch} **and** {@link MapboxAutofill} instances. Both\n * of these have similar workflows, but are separate APIs with different options\n * and responses.\n *\n * In order to make TypeScript happy, this type is an \"approximation\" of what\n * {@link SearchSession} uses. When you construct a new {@link SearchSession},\n * because of this type [Options, Suggestion, SuggestionResponse, RetrieveResponse]\n * are automatically inferred.\n *\n * @internal\n * @example\n * ```typescript\n * const autofill = new MapboxAutofill({\n *  accessToken: 'pk.my-fancy-token',\n * });\n *\n * const session = new SearchSession(autofill);\n *\n * `session` has inferred type = SearchSession<\n *   AutofillOptions,\n *   AutofillSuggestion,\n *   AutofillSuggestionResponse,\n *   AutofillRetrieveResponse\n * >\n * ```\n */\ntype SuggestSearch<Options, Suggestion, SuggestionResponse, RetrieveResponse> =\n  {\n    suggest: (\n      text: string,\n      options: Partial<Options> & {\n        sessionToken: SessionTokenLike;\n        signal: AbortSignal;\n      }\n    ) => Promise<SuggestionResponse>;\n    retrieve: (\n      suggestion: Suggestion,\n      options: Partial<Options> & {\n        sessionToken: SessionTokenLike;\n      }\n    ) => Promise<RetrieveResponse>;\n    canRetrieve?: (suggestion: Suggestion) => boolean;\n    canSuggest?: (suggestion: Suggestion) => boolean;\n  };\n\n/**\n * A `SearchSession` object is a managed entrypoint to the [Mapbox Search API](https://docs.mapbox.com/api/search/search/)\n * or Mapbox Autocomplete API.\n *\n * `SearchSession` abstracts the suggest/retrieve flow of the two-step interactive search experience.\n *\n * Compared to using these APIs directly, you can use a `SearchSession` to:\n * 1. Automatically manage the session token lifecycle.\n * 2. Debounce calls to {@link SearchSession#suggest}.\n * 2. Abort in-flight requests with an imperative API.\n *\n * @class SearchSession\n * @example\n * ```typescript\n * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n * const session = new SearchSession(search);\n *\n * session.addEventListener('suggest', (res) => {\n *   presentResultsToUser(res.suggestions);\n * });\n *\n * session.addEventListener('retrieve', (res) => {\n *   doSomethingWithFeatureCollection(res);\n * });\n *\n * document.querySelector('button').addEventListener('click', (event) => {\n *   const suggestions = session.suggestions?.suggestions;\n *   if (!suggestions || !suggestions.length) {\n *     return;\n *   }\n *\n *   const suggestion = suggestions[0];\n *   if (session.canRetrieve(suggestion)) {\n *     session.retrieve(suggestion);\n *   } else if (session.canSuggest(suggestion)) {\n *     // .. go through suggest flow again ..\n *     session.suggest(suggestion.text);\n *   }\n * });\n *\n * session.suggest('Washington D.C.');\n * ```\n * @param {MapboxSearch | MapboxAutofill} search - The search interface to wrap.\n * @param {number} wait - The time in milliseconds to wait before sending a new request to the {@link SearchSession#suggest} call.\n */\nexport class SearchSession<\n  Options,\n  Suggestion,\n  SuggestionResponse,\n  RetrieveResponse\n> extends Evented<EventTypes<SuggestionResponse, RetrieveResponse>> {\n  readonly search: SuggestSearch<\n    Options,\n    Suggestion,\n    SuggestionResponse,\n    RetrieveResponse\n  >;\n\n  /**\n   * The time in milliseconds to wait before sending a new request to the\n   * {@link SearchSession#suggest} call.\n   */\n  readonly debounce: number;\n\n  /**\n   * If true, the existing session token will continue to be used regardless\n   * of is expiration state or the number of suggest calls made with it.\n   *\n   * This is used among Autofill components to ensure that a session endures\n   * across the lifecycle of an Autofill checkout process.\n   */\n  #persistSessionToken = false;\n\n  /**\n   * The session token is an SKU (billing token) used to identify the current\n   * search session and provide analytics to the customer.\n   *\n   * As per {@link SessionToken}, this is a UUIDv4 value.\n   *\n   * In the following instances, a new session token is generated:\n   * - On a successful {@link SearchSession#retrieve} call.\n   * - After a certain time (60 min).\n   * - After 50 suggests.\n   */\n  #sessionToken = new SessionToken();\n\n  /**\n   * The {@link SessionToken} used within the current session.\n   *\n   * By default, this value is managed internally and automatically regenerated\n   * according to its lifecycle criteria, i.e. time, number of calls to suggest,\n   * and a call to retrieve.\n   *\n   * This value should not be explicitly set except within the Autofill web\n   * component library, as doing so will persist the token for the duration\n   * of those component lifecycles.\n   */\n  get sessionToken(): SessionToken {\n    return this.#sessionToken;\n  }\n  set sessionToken(token: SessionToken) {\n    this.#sessionToken = token;\n    this.#persistSessionToken = true;\n  }\n\n  /**\n   * Number of times the session token has been used.\n   *\n   * Kept in sync by {@link SearchSession##getSessionTokenForSuggest}.\n   */\n  #sessionTokenRef = 0;\n\n  #getSessionTokenForSuggest(): SessionToken {\n    if (!this.#persistSessionToken) {\n      // 1. If the session token is expired.\n      // 2. If the session token has been used more than 50 times.\n      if (\n        this.#sessionToken.isExpired() ||\n        this.#sessionTokenRef >= SESSION_TOKEN_NUM\n      ) {\n        this.#sessionToken = new SessionToken();\n        // Reset counter.\n        this.#sessionTokenRef = 0;\n      }\n    }\n\n    this.#sessionTokenRef++;\n    return this.#sessionToken;\n  }\n\n  #suggestions: SuggestionResponse | null;\n\n  /**\n   * The suggestions from the last successful suggest call, if any.\n   */\n  get suggestions(): SuggestionResponse | null {\n    return this.#suggestions;\n  }\n\n  constructor(\n    search: SuggestSearch<\n      Options,\n      Suggestion,\n      SuggestionResponse,\n      RetrieveResponse\n    >,\n    wait = 0\n  ) {\n    super();\n\n    // Set 'suggest' method using debounce.\n    this.#suggestDebounce = debounce(\n      async (\n        searchText: string,\n        options: Partial<Options> = {}\n      ): Promise<void> => {\n        // Refresh abort controller.\n        this.#abort.abort();\n        this.#abort = createAbortController();\n\n        if (!searchText) {\n          this.#suggestions = null;\n          this.fire('suggest', this.#suggestions);\n          return;\n        }\n\n        const sessionToken = this.#getSessionTokenForSuggest();\n\n        try {\n          const res = await this.search.suggest(searchText, {\n            sessionToken,\n            ...options,\n            signal: this.#abort.signal\n          });\n\n          this.#suggestions = res;\n          this.fire('suggest', res);\n        } catch (err) {\n          if (err.name === 'AbortError') {\n            return;\n          }\n\n          this.fire('suggesterror', err);\n        }\n      },\n      wait,\n      () => this.#abort.signal\n    );\n\n    /**\n     * Define properties using {@link Object#defineProperties} so they are readonly during runtime,\n     * not just in TypeScript.\n     */\n    Object.defineProperties(this, {\n      search: {\n        value: search,\n        writable: false\n      },\n      debounce: {\n        value: wait,\n        writable: false\n      }\n    });\n  }\n\n  /**\n   * The {@link AbortController} is used to abort the current suggest, either\n   * because of a new {@link SearchSession#suggest} call, or because\n   * of {@link SearchSession#abort}.\n   *\n   * In both of these cases, a new {@link AbortController} is created,\n   * and the old one is aborted.\n   */\n  #abort = createAbortController();\n\n  #suggestDebounce: (searchText: string, options?: Partial<Options>) => void;\n\n  /** @section {Methods} */\n\n  /**\n   * {@link SearchSession#suggest} is \"part one\" of the two-step interactive search experience,\n   * and each suggestion includes metadata to present to the user.\n   *\n   * Suggestion objects **do not include geographic coordinates**. To get the coordinates of the result, use {@link SearchSession#retrieve}.\n   *\n   * It may be useful to call {@link SearchSession#canRetrieve} before calling this method, as the suggestion may be a reference to\n   * another suggest query. This can also be tested with {@link SearchSession#canSuggest}, and further calls to {@link SearchSession#suggest}.\n   *\n   * Results can be retrieved with the \"suggest\" event.\n   *\n   * @example\n   * ```typescript\n   * const search = new MapboxSearch({ accessToken: 'pk.my-mapbox-access-token' });\n   * const session = new SearchSession(search);\n   *\n   * session.addEventListener('suggest', (res) => {\n   *   presentResultsToUser(res.suggestions);\n   * });\n   *\n   * session.suggest('Washington D.C.');\n   * ```\n   */\n  suggest(\n    searchText: string,\n    options?: Partial<Options>\n  ): Promise<SuggestionResponse> {\n    this.#suggestDebounce(searchText, options);\n\n    return new Promise((resolve, reject) => {\n      let suggestFn: (val: SuggestionResponse) => void;\n      let suggestErrorFn: (val: Error) => void;\n\n      suggestFn = (res) => {\n        this.removeEventListener('suggest', suggestFn);\n        this.removeEventListener('suggesterror', suggestErrorFn);\n        resolve(res);\n      };\n      suggestErrorFn = (err) => {\n        this.removeEventListener('suggest', suggestFn);\n        this.removeEventListener('suggesterror', suggestErrorFn);\n        reject(err);\n      };\n\n      this.addEventListener('suggest', suggestFn);\n      this.addEventListener('suggesterror', suggestErrorFn);\n    });\n  }\n\n  /**\n   * Clears the current suggestions.\n   */\n  clear(): void {\n    this.suggest('');\n  }\n\n  /**\n   * {@link SearchSession#retrieve} is \"part two\" of the two-step interactive search experience and includes\n   * geographic coordinates in [GeoJSON](https://docs.mapbox.com/help/glossary/geojson/) format.\n   *\n   * {@link suggestion} is usually a {@link Suggestion} returned from \"part one,\" {@link SearchSession#suggest}.\n   *\n   * Multiple feature suggestions may be returned from a single search query, for example in an airport with\n   * multiple terminals.\n   *\n   * **Legal terms:**\n   *\n   * Due to legal terms from our data sources, results should not be stored in a customer database.\n   * Results should be used ephemerally and not persisted.\n   *\n   * This permanent policy is consistent with the [Mapbox Terms of Service](https://www.mapbox.com/tos/) and failure to comply\n   * may result in modified or discontinued service.\n   *\n   * Additionally, the [Mapbox Terms of Service](https://www.mapbox.com/tos/) states any rendering of a feature suggestion\n   * must be using Mapbox map services (for example, displaying results on Google Maps or MapKit JS is not allowed).\n   *\n   * **Disclaimer:**\n   *\n   * The failure of Mapbox to exercise or enforce any right or provision of these Terms will not constitute a waiver of such right or provision.\n   */\n  async retrieve(\n    suggestion: Suggestion,\n    options?: Partial<Options>\n  ): Promise<RetrieveResponse> {\n    const res = await this.search.retrieve(suggestion, {\n      sessionToken: this.#sessionToken,\n      ...options\n    });\n\n    if (!this.#persistSessionToken) {\n      // Reset session token.\n      this.#sessionToken = new SessionToken();\n      // Reset counter.\n      this.#sessionTokenRef = 0;\n    }\n\n    this.fire('retrieve', res);\n    return res;\n  }\n\n  /**\n   * Returns true if {@link SearchSession#retrieve} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) has geographic coordinates\n   * for this suggestion.\n   *\n   * This method is mutually exclusive with {@link SearchSession#canSuggest}.\n   */\n  canRetrieve(suggestion: Suggestion): boolean {\n    if (!this.search.canRetrieve) {\n      return true;\n    }\n\n    return this.search.canRetrieve(suggestion);\n  }\n\n  /**\n   * Returns true if {@link SearchSession#suggest} can be called on this suggestion,\n   * false otherwise.\n   *\n   * This indicates the [Mapbox Search API](https://docs.mapbox.com/api/search/search/) wants to do another\n   * suggestion search on this result, and does not have geographic coordinates.\n   *\n   * This method is mutually exclusive with {@link SearchSession#canRetrieve}.\n   */\n  canSuggest(suggestion: Suggestion): boolean {\n    if (!this.search.canSuggest) {\n      return true;\n    }\n\n    return this.search.canSuggest(suggestion);\n  }\n\n  /**\n   * Aborts the current {@link SearchSession#suggest} request.\n   */\n  abort(): void {\n    this.#abort.abort();\n    this.#abort = createAbortController();\n  }\n}\n","import { FeatureSuggestion, Suggestion } from './search/types';\nimport {\n  AutofillFeatureSuggestion,\n  AutofillSuggestion\n} from './autofill/types';\n\nfunction featureToSuggestion(feature: FeatureSuggestion): Suggestion;\n\nfunction featureToSuggestion(\n  feature: AutofillFeatureSuggestion\n): AutofillSuggestion;\n\n/**\n * Utility function to convert the {@link FeatureSuggestion} properties to a\n * {@link Suggestion} object.\n */\nfunction featureToSuggestion(\n  feature: FeatureSuggestion | AutofillFeatureSuggestion\n): Suggestion | AutofillSuggestion {\n  const { properties } = feature;\n  return {\n    ...properties\n  };\n}\n\nexport { featureToSuggestion };\n"]},"metadata":{},"sourceType":"module"}