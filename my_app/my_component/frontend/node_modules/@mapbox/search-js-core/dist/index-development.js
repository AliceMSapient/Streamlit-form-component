var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  };
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AutofillMatchCodeConfidence: () => AutofillMatchCodeConfidence,
  Evented: () => Evented,
  LngLat: () => LngLat,
  LngLatBounds: () => LngLatBounds,
  MapboxAutofill: () => MapboxAutofill,
  MapboxError: () => MapboxError,
  MapboxSearch: () => MapboxSearch,
  SearchSession: () => SearchSession,
  SessionToken: () => SessionToken,
  featureToSuggestion: () => featureToSuggestion,
  polyfillFetch: () => polyfillFetch
});

// src/search/constants.ts
var SEARCH_URL = `https://api.mapbox.com/search/v1`;
var ENDPOINT_SUGGEST = "suggest";
var ENDPOINT_RETRIEVE = "retrieve";
var ENDPOINT_FORWARD = "forward";
var ENDPOINT_REVERSE = "reverse";
var SUGGEST_URL = `${SEARCH_URL}/${ENDPOINT_SUGGEST}`;
var RETRIEVE_URL = `${SEARCH_URL}/${ENDPOINT_RETRIEVE}`;
var FORWARD_URL = `${SEARCH_URL}/${ENDPOINT_FORWARD}`;
var PERMANENT_FORWARD_URL = `${SEARCH_URL}/permanent/${ENDPOINT_FORWARD}`;
var REVERSE_URL = `${SEARCH_URL}/${ENDPOINT_REVERSE}`;
var PERMANENT_REVERSE_URL = `${SEARCH_URL}/permanent/${ENDPOINT_REVERSE}`;

// src/LngLat.ts
var LngLat = class {
  constructor(lng, lat) {
    if (isNaN(lng) || isNaN(lat)) {
      throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);
    }
    this.lng = +lng;
    this.lat = +lat;
    if (this.lat > 90 || this.lat < -90) {
      throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
    }
    if (this.lng > 180 || this.lng < -180) {
      throw new Error("Invalid LngLat longitude value: must be between -180 and 180");
    }
  }
  toArray() {
    return [this.lng, this.lat];
  }
  toString() {
    return `LngLat(${this.lng}, ${this.lat})`;
  }
  static convert(input) {
    if (input instanceof LngLat) {
      return new LngLat(input.lng, input.lat);
    }
    if (Array.isArray(input) && input.length === 2) {
      return new LngLat(Number(input[0]), Number(input[1]));
    }
    if (!Array.isArray(input) && typeof input == "object" && input !== null && ("lng" in input || "lon" in input) && "lat" in input) {
      return new LngLat(Number("lng" in input ? input.lng : input.lon), Number(input.lat));
    }
    throw new Error("`LngLatLike` argument must be specified as an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
  }
};

// src/LngLatBounds.ts
var LngLatBounds = class {
  constructor(sw, ne) {
    this._sw = LngLat.convert(sw);
    this._ne = LngLat.convert(ne);
  }
  getSouthWest() {
    return this._sw;
  }
  getNorthEast() {
    return this._ne;
  }
  getNorthWest() {
    return new LngLat(this.getWest(), this.getNorth());
  }
  getSouthEast() {
    return new LngLat(this.getEast(), this.getSouth());
  }
  getWest() {
    return this._sw.lng;
  }
  getSouth() {
    return this._sw.lat;
  }
  getEast() {
    return this._ne.lng;
  }
  getNorth() {
    return this._ne.lat;
  }
  toArray() {
    return [this._sw.toArray(), this._ne.toArray()];
  }
  toFlatArray() {
    return [this._sw.lng, this._sw.lat, this._ne.lng, this._ne.lat];
  }
  toString() {
    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
  }
  static convert(input) {
    if (!input) {
      throw new Error("Invalid LngLatBounds convert value: falsy");
    }
    if (input instanceof LngLatBounds) {
      return new LngLatBounds(input.getSouthWest(), input.getNorthEast());
    }
    if (Array.isArray(input) && input.length === 2) {
      return new LngLatBounds(LngLat.convert(input[0]), LngLat.convert(input[1]));
    }
    if (Array.isArray(input) && input.length === 4) {
      return new LngLatBounds(LngLat.convert([input[0], input[1]]), LngLat.convert([input[2], input[3]]));
    }
    throw new Error("`LngLatBoundsLike` argument must be specified as an array [<LngLatLike>, <LngLatLike>] or an array [<west>, <south>, <east>, <north>]");
  }
};

// src/utils/uuid.ts
var import_polyfill_crypto = __toESM(require("polyfill-crypto.getrandomvalues"));
function getRandomValues(arr) {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.getRandomValues !== "function") {
    return (0, import_polyfill_crypto.default)(arr);
  }
  return globalThis.crypto.getRandomValues(arr);
}
function bytesToUuid(bytes) {
  const bits = [...bytes].map((bit) => {
    const s = bit.toString(16);
    return bit < 16 ? "0" + s : s;
  });
  return [
    ...bits.slice(0, 4),
    "-",
    ...bits.slice(4, 6),
    "-",
    ...bits.slice(6, 8),
    "-",
    ...bits.slice(8, 10),
    "-",
    ...bits.slice(10, 16)
  ].join("");
}
function generateUUID() {
  const rnds = getRandomValues(new Uint8Array(16));
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return bytesToUuid(rnds);
}

// src/SessionToken.ts
var SESSION_TOKEN_EXPIRY = 60 * 60 * 1e3;
var SessionToken = class {
  constructor(id, ts = Date.now()) {
    this.id = id != null ? id : generateUUID();
    this.ts = ts;
  }
  toString() {
    return this.id;
  }
  static convert(token) {
    return new SessionToken(token instanceof SessionToken ? token.id : token.toString(), token instanceof SessionToken ? token.ts : Date.now());
  }
  isExpired() {
    return Date.now() - this.ts > SESSION_TOKEN_EXPIRY;
  }
};

// src/MapboxError.ts
var UNKNOWN_ERROR = "Unknown error";
var MapboxError = class extends Error {
  constructor(json, statusCode) {
    super(String(json.message || json.error || UNKNOWN_ERROR));
    this.name = "MapboxError";
    this.statusCode = statusCode;
  }
  toString() {
    return `${this.name} (${this.statusCode}): ${this.message}`;
  }
};
function handleNonOkRes(res) {
  return __async(this, null, function* () {
    if (!res.ok) {
      const json = yield res.json();
      throw new MapboxError(json, res.status);
    }
  });
}

// src/fetch.ts
var _fetchImpl = globalThis.fetch;
var _abortControllerImpl = globalThis.AbortController;
function polyfillFetch({ fetch, AbortController }, force = false) {
  if (!fetch) {
    throw new Error("Fetch implementation must include implementations of `fetch`.");
  }
  if (_fetchImpl && !force) {
    return;
  }
  _fetchImpl = fetch;
  _abortControllerImpl = AbortController;
}
function getFetch() {
  if (!_fetchImpl) {
    throw new Error("Fetch implementation not found. Please use `polyfillFetch` from `@mapbox/search-js-core` to fix this issue.");
  }
  return {
    fetch: _fetchImpl,
    AbortController: _abortControllerImpl
  };
}
function nodeRequire(fn, str) {
  return fn(str);
}
if (!_fetchImpl && true && process.versions.node) {
  const { default: fetch } = nodeRequire(require, "node-fetch");
  const AbortController = nodeRequire(require, "abort-controller");
  polyfillFetch({
    fetch,
    AbortController
  });
}

// src/utils/queryParams.ts
function queryParams(...objects) {
  const params = [];
  for (const obj of objects) {
    if (!obj)
      continue;
    const entries = Object.entries(obj);
    for (const [key, value] of entries) {
      if (value == null)
        continue;
      params.push(`${key}=${encodeURIComponent(String(value))}`);
    }
  }
  return params.join("&");
}

// src/search/MapboxSearch.ts
var _getQueryParams, getQueryParams_fn, _getFetchInfo, getFetchInfo_fn;
var _MapboxSearch = class {
  constructor(options = {}) {
    __privateAdd(this, _getQueryParams);
    __privateAdd(this, _getFetchInfo);
    const _a = options, { accessToken } = _a, defaults = __objRest(_a, ["accessToken"]);
    this.accessToken = accessToken;
    this.defaults = __spreadValues(__spreadValues({}, _MapboxSearch.defaults), defaults);
  }
  suggest(searchText, optionsArg) {
    return __async(this, null, function* () {
      if (!searchText) {
        throw new Error("searchText is required");
      }
      if (!this.accessToken) {
        throw new Error("accessToken is required");
      }
      if (!optionsArg || !optionsArg.sessionToken) {
        throw new Error("sessionToken is required");
      }
      const { sessionToken, signal } = optionsArg;
      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {
        sessionToken
      });
      if (options.eta_type && (!options.origin || !options.navigation_profile)) {
        throw new Error("to provide eta estimate: eta, navigation_profile, and origin are required");
      }
      if (options.origin && !options.navigation_profile) {
        throw new Error("to provide distance estimate: both navigation_profile and origin are required");
      }
      const url = new URL(`${SUGGEST_URL}/${encodeURIComponent(searchText)}`);
      url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);
      const { fetch } = getFetch();
      const res = yield fetch(url.toString(), {
        signal
      });
      yield handleNonOkRes(res);
      const json = yield res.json();
      return json;
    });
  }
  retrieve(suggestion, optionsArg) {
    return __async(this, null, function* () {
      if (!suggestion) {
        throw new Error("suggestion is required");
      }
      if (!this.accessToken) {
        throw new Error("accessToken is required");
      }
      if (!this.canRetrieve(suggestion)) {
        throw new Error("suggestion cannot be retrieved");
      }
      if (!optionsArg || !optionsArg.sessionToken) {
        throw new Error("sessionToken is required");
      }
      const { sessionToken: sessionTokenLike, signal } = optionsArg;
      const sessionToken = SessionToken.convert(sessionTokenLike);
      const url = new URL(RETRIEVE_URL);
      url.search = queryParams({
        access_token: this.accessToken,
        session_token: sessionToken.id
      });
      const { fetch } = getFetch();
      const res = yield fetch(url.toString(), __spreadProps(__spreadValues({}, __privateMethod(this, _getFetchInfo, getFetchInfo_fn).call(this, suggestion)), {
        signal
      }));
      yield handleNonOkRes(res);
      const json = yield res.json();
      return json;
    });
  }
  canRetrieve(suggestion) {
    const action = suggestion.action;
    if (!action) {
      return false;
    }
    return action.method === "POST" && action.endpoint === ENDPOINT_RETRIEVE;
  }
  canSuggest(suggestion) {
    const action = suggestion.action;
    if (!action) {
      return false;
    }
    return action.method === "POST" && action.endpoint === ENDPOINT_SUGGEST;
  }
  forward(_0) {
    return __async(this, arguments, function* (searchText, optionsArg = {}) {
      if (!searchText) {
        throw new Error("searchText is required");
      }
      if (!this.accessToken) {
        throw new Error("accessToken is required");
      }
      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);
      const baseUrl = options.permanent ? PERMANENT_FORWARD_URL : FORWARD_URL;
      const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);
      url.search = __privateMethod(this, _getQueryParams, getQueryParams_fn).call(this, options);
      const { fetch } = getFetch();
      const res = yield fetch(url.toString(), {
        signal: options.signal
      });
      yield handleNonOkRes(res);
      const json = yield res.json();
      return json;
    });
  }
  reverse(_0) {
    return __async(this, arguments, function* (lngLat, optionsArg = {}) {
      if (!lngLat) {
        throw new Error("lngLat is required");
      }
      if (!this.accessToken) {
        throw new Error("accessToken is required");
      }
      const options = __spreadValues(__spreadValues({}, this.defaults), optionsArg);
      const searchText = typeof lngLat === "string" ? lngLat : LngLat.convert(lngLat).toArray().join(",");
      const baseUrl = options.permanent ? PERMANENT_REVERSE_URL : REVERSE_URL;
      const url = new URL(`${baseUrl}/${encodeURIComponent(searchText)}`);
      url.search = queryParams({
        access_token: this.accessToken,
        language: options.language,
        limit: options.limit
      }, options.types && {
        types: typeof options.types === "string" ? options.types : [...options.types].join(",")
      });
      const { fetch } = getFetch();
      const res = yield fetch(url.toString(), {
        signal: options.signal
      });
      yield handleNonOkRes(res);
      const json = yield res.json();
      return json;
    });
  }
};
var MapboxSearch = _MapboxSearch;
_getQueryParams = new WeakSet();
getQueryParams_fn = function(options) {
  return queryParams({
    access_token: this.accessToken,
    language: options.language,
    country: options.country,
    limit: options.limit,
    navigation_profile: options.navigation_profile,
    eta_type: options.eta_type
  }, options.sessionToken && {
    session_token: SessionToken.convert(options.sessionToken).id
  }, options.origin && {
    origin: typeof options.origin === "string" ? options.origin : LngLat.convert(options.origin).toArray().join(",")
  }, options.proximity && {
    proximity: typeof options.proximity === "string" ? options.proximity : LngLat.convert(options.proximity).toArray().join(",")
  }, options.bbox && {
    bbox: typeof options.bbox === "string" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(",")
  }, options.types && {
    types: typeof options.types === "string" ? options.types : [...options.types].join(",")
  });
};
_getFetchInfo = new WeakSet();
getFetchInfo_fn = function(suggestion) {
  if (!this.canRetrieve(suggestion) && !this.canSuggest(suggestion)) {
    throw new Error("Suggestion cannot be retrieved or suggested");
  }
  const action = suggestion.action;
  const body = JSON.stringify(action.body);
  return {
    method: action.method,
    body,
    headers: {
      "Content-Type": "application/json",
      "Content-Length": body.length.toString()
    }
  };
};
MapboxSearch.defaults = {
  language: "en"
};

// src/autofill/constants.ts
var SEARCH_URL2 = `https://api.mapbox.com/autofill/v1`;
var ENDPOINT_SUGGEST2 = "suggest";
var ENDPOINT_RETRIEVE2 = "retrieve";
var SUGGEST_URL2 = `${SEARCH_URL2}/${ENDPOINT_SUGGEST2}`;
var RETRIEVE_URL2 = `${SEARCH_URL2}/${ENDPOINT_RETRIEVE2}`;

// src/autofill/MapboxAutofill.ts
var _getQueryParams2, getQueryParams_fn2;
var _MapboxAutofill = class {
  constructor(options = {}) {
    __privateAdd(this, _getQueryParams2);
    const _a = options, { accessToken } = _a, defaults = __objRest(_a, ["accessToken"]);
    this.accessToken = accessToken;
    this.defaults = __spreadValues(__spreadValues({}, _MapboxAutofill.defaults), defaults);
  }
  suggest(searchText, optionsArg) {
    return __async(this, null, function* () {
      if (!searchText) {
        throw new Error("searchText is required");
      }
      if (!this.accessToken) {
        throw new Error("accessToken is required");
      }
      if (!optionsArg || !optionsArg.sessionToken) {
        throw new Error("sessionToken is required");
      }
      const { sessionToken, signal } = optionsArg;
      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {
        sessionToken
      });
      const url = new URL(`${SUGGEST_URL2}/${encodeURIComponent(searchText)}`);
      url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);
      const { fetch } = getFetch();
      const res = yield fetch(url.toString(), {
        signal
      });
      yield handleNonOkRes(res);
      const json = yield res.json();
      return __spreadProps(__spreadValues({}, json), {
        suggestions: json.suggestions.map((suggestion) => {
          return __spreadProps(__spreadValues({}, suggestion), {
            original_search_text: searchText
          });
        })
      });
    });
  }
  retrieve(suggestion, optionsArg) {
    return __async(this, null, function* () {
      if (!suggestion) {
        throw new Error("suggestion is required");
      }
      if (!this.accessToken) {
        throw new Error("accessToken is required");
      }
      if (!optionsArg || !optionsArg.sessionToken) {
        throw new Error("sessionToken is required");
      }
      const { sessionToken, signal } = optionsArg;
      const options = __spreadProps(__spreadValues(__spreadValues({}, this.defaults), optionsArg), {
        sessionToken
      });
      const isRichSuggestion = typeof suggestion !== "string";
      const searchText = isRichSuggestion ? suggestion.original_search_text : suggestion;
      const url = new URL(`${RETRIEVE_URL2}/${encodeURIComponent(searchText)}`);
      url.search = __privateMethod(this, _getQueryParams2, getQueryParams_fn2).call(this, options);
      const { fetch } = getFetch();
      const res = yield fetch(url.toString(), {
        signal
      });
      yield handleNonOkRes(res);
      const json = yield res.json();
      if (!isRichSuggestion) {
        return json;
      }
      return __spreadProps(__spreadValues({}, json), {
        features: json.features.filter((feature) => {
          return feature.properties.full_address === suggestion.full_address;
        })
      });
    });
  }
};
var MapboxAutofill = _MapboxAutofill;
_getQueryParams2 = new WeakSet();
getQueryParams_fn2 = function(options) {
  return queryParams({
    access_token: this.accessToken,
    language: options.language,
    country: options.country,
    limit: options.limit
  }, options.sessionToken && {
    session_token: SessionToken.convert(options.sessionToken).id
  }, options.proximity && {
    proximity: typeof options.proximity === "string" ? options.proximity : LngLat.convert(options.proximity).toArray().join(",")
  }, options.bbox && {
    bbox: typeof options.bbox === "string" ? options.bbox : LngLatBounds.convert(options.bbox).toFlatArray().join(",")
  });
};
MapboxAutofill.defaults = {
  language: "en",
  proximity: "ip"
};

// src/autofill/types.ts
var AutofillMatchCodeConfidence = /* @__PURE__ */ ((AutofillMatchCodeConfidence2) => {
  AutofillMatchCodeConfidence2["exact"] = "exact";
  AutofillMatchCodeConfidence2["high"] = "high";
  AutofillMatchCodeConfidence2["medium"] = "medium";
  AutofillMatchCodeConfidence2["low"] = "low";
  return AutofillMatchCodeConfidence2;
})(AutofillMatchCodeConfidence || {});

// src/utils/Evented.ts
var _listeners;
var Evented = class {
  constructor() {
    __privateAdd(this, _listeners, {});
  }
  addEventListener(type, listener) {
    const listenersArr = __privateGet(this, _listeners);
    if (!listenersArr[type]) {
      listenersArr[type] = [];
    }
    listenersArr[type].push(listener);
  }
  removeEventListener(type, listener) {
    const listenersArr = __privateGet(this, _listeners);
    if (!listenersArr[type]) {
      return;
    }
    const listeners = listenersArr[type];
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
  }
  fire(type, arg0) {
    const listenersArr = __privateGet(this, _listeners);
    if (!listenersArr[type]) {
      return;
    }
    const listeners = listenersArr[type];
    for (const listener of listeners) {
      listener(arg0);
    }
  }
};
_listeners = new WeakMap();

// src/utils/debounce.ts
function debounce(func, wait, signalFn) {
  let timeout = null;
  return (...args) => {
    if (timeout !== null) {
      clearTimeout(timeout);
    }
    const signal = signalFn && signalFn();
    timeout = setTimeout(() => {
      timeout = null;
      if (signal == null ? void 0 : signal.aborted) {
        return;
      }
      func(...args);
    }, wait);
  };
}

// src/SearchSession.ts
var SESSION_TOKEN_NUM = 50;
function createAbortController() {
  const { AbortController } = getFetch();
  return new AbortController();
}
var _persistSessionToken, _sessionToken, _sessionTokenRef, _getSessionTokenForSuggest, getSessionTokenForSuggest_fn, _suggestions, _abort, _suggestDebounce;
var SearchSession = class extends Evented {
  constructor(search, wait = 0) {
    super();
    __privateAdd(this, _getSessionTokenForSuggest);
    __privateAdd(this, _persistSessionToken, false);
    __privateAdd(this, _sessionToken, new SessionToken());
    __privateAdd(this, _sessionTokenRef, 0);
    __privateAdd(this, _suggestions, void 0);
    __privateAdd(this, _abort, createAbortController());
    __privateAdd(this, _suggestDebounce, void 0);
    __privateSet(this, _suggestDebounce, debounce((_0, ..._1) => __async(this, [_0, ..._1], function* (searchText, options = {}) {
      __privateGet(this, _abort).abort();
      __privateSet(this, _abort, createAbortController());
      if (!searchText) {
        __privateSet(this, _suggestions, null);
        this.fire("suggest", __privateGet(this, _suggestions));
        return;
      }
      const sessionToken = __privateMethod(this, _getSessionTokenForSuggest, getSessionTokenForSuggest_fn).call(this);
      try {
        const res = yield this.search.suggest(searchText, __spreadProps(__spreadValues({
          sessionToken
        }, options), {
          signal: __privateGet(this, _abort).signal
        }));
        __privateSet(this, _suggestions, res);
        this.fire("suggest", res);
      } catch (err) {
        if (err.name === "AbortError") {
          return;
        }
        this.fire("suggesterror", err);
      }
    }), wait, () => __privateGet(this, _abort).signal));
    Object.defineProperties(this, {
      search: {
        value: search,
        writable: false
      },
      debounce: {
        value: wait,
        writable: false
      }
    });
  }
  get sessionToken() {
    return __privateGet(this, _sessionToken);
  }
  set sessionToken(token) {
    __privateSet(this, _sessionToken, token);
    __privateSet(this, _persistSessionToken, true);
  }
  get suggestions() {
    return __privateGet(this, _suggestions);
  }
  suggest(searchText, options) {
    __privateGet(this, _suggestDebounce).call(this, searchText, options);
    return new Promise((resolve, reject) => {
      let suggestFn;
      let suggestErrorFn;
      suggestFn = (res) => {
        this.removeEventListener("suggest", suggestFn);
        this.removeEventListener("suggesterror", suggestErrorFn);
        resolve(res);
      };
      suggestErrorFn = (err) => {
        this.removeEventListener("suggest", suggestFn);
        this.removeEventListener("suggesterror", suggestErrorFn);
        reject(err);
      };
      this.addEventListener("suggest", suggestFn);
      this.addEventListener("suggesterror", suggestErrorFn);
    });
  }
  clear() {
    this.suggest("");
  }
  retrieve(suggestion, options) {
    return __async(this, null, function* () {
      const res = yield this.search.retrieve(suggestion, __spreadValues({
        sessionToken: __privateGet(this, _sessionToken)
      }, options));
      if (!__privateGet(this, _persistSessionToken)) {
        __privateSet(this, _sessionToken, new SessionToken());
        __privateSet(this, _sessionTokenRef, 0);
      }
      this.fire("retrieve", res);
      return res;
    });
  }
  canRetrieve(suggestion) {
    if (!this.search.canRetrieve) {
      return true;
    }
    return this.search.canRetrieve(suggestion);
  }
  canSuggest(suggestion) {
    if (!this.search.canSuggest) {
      return true;
    }
    return this.search.canSuggest(suggestion);
  }
  abort() {
    __privateGet(this, _abort).abort();
    __privateSet(this, _abort, createAbortController());
  }
};
_persistSessionToken = new WeakMap();
_sessionToken = new WeakMap();
_sessionTokenRef = new WeakMap();
_getSessionTokenForSuggest = new WeakSet();
getSessionTokenForSuggest_fn = function() {
  if (!__privateGet(this, _persistSessionToken)) {
    if (__privateGet(this, _sessionToken).isExpired() || __privateGet(this, _sessionTokenRef) >= SESSION_TOKEN_NUM) {
      __privateSet(this, _sessionToken, new SessionToken());
      __privateSet(this, _sessionTokenRef, 0);
    }
  }
  __privateWrapper(this, _sessionTokenRef)._++;
  return __privateGet(this, _sessionToken);
};
_suggestions = new WeakMap();
_abort = new WeakMap();
_suggestDebounce = new WeakMap();

// src/featureToSuggestion.ts
function featureToSuggestion(feature) {
  const { properties } = feature;
  return __spreadValues({}, properties);
}
module.exports = __toCommonJS(src_exports);
//# sourceMappingURL=index-development.js.map
