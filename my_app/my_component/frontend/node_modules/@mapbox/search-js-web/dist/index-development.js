var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  MapboxAddressAutofill: () => MapboxAddressAutofill,
  MapboxAddressConfirmation: () => MapboxAddressConfirmation,
  MapboxAddressMinimap: () => MapboxAddressMinimap,
  MapboxHTMLEvent: () => MapboxHTMLEvent,
  MapboxSearchBox: () => MapboxSearchBox,
  autofill: () => autofill,
  config: () => config,
  confirmAddress: () => confirmAddress,
  getAutofillSearchText: () => getAutofillSearchText,
  getFormAutofillValues: () => getFormAutofillValues
});

// src/components/MapboxSearchListbox.ts
var import_popper_lite = require("@popperjs/core/lib/popper-lite");

// src/utils/dom.ts
var subdoc = document.implementation.createHTMLDocument();
function bindElements(root, elements) {
  const binding = {};
  for (const [key, selector] of Object.entries(elements)) {
    binding[key] = root.querySelector(selector);
  }
  return binding;
}
function getChildElements(node) {
  return Array.from(node.childNodes || []).filter((el) => el.nodeType === Node.ELEMENT_NODE);
}
function createElementFromString(innerHTML) {
  const template = document.createElement("template");
  template.innerHTML = innerHTML;
  return template.content.firstElementChild;
}
function createCSSStyleSheet(text) {
  const style = subdoc.createElement("style");
  style.textContent = text;
  subdoc.head.appendChild(style);
  return style.sheet;
}
function isVisible(element) {
  const style = window.getComputedStyle(element);
  return style.display !== "none";
}
function setValue(input, value) {
  if (!input) {
    return;
  }
  const set = Object.getOwnPropertyDescriptor(input.constructor.prototype, "value").set;
  set.call(input, value);
  const wrapperState = input;
  if (wrapperState._valueTracker) {
    wrapperState._valueTracker.setValue("");
  }
  const onInputEvent = new Event("input", {
    bubbles: true
  });
  onInputEvent.simulated = true;
  input.dispatchEvent(onInputEvent);
  const onChangeEvent = new Event("change", {
    bubbles: true
  });
  onChangeEvent.simulated = true;
  input.dispatchEvent(onChangeEvent);
}
function getElementSize(element, deep = false) {
  let width;
  let height;
  const elementRect = element.getBoundingClientRect();
  if (element.style.display === "none" || elementRect.height === 0 && elementRect.width === 0) {
    const clone = element.cloneNode(deep);
    element.parentElement.appendChild(clone);
    clone.style.setProperty("display", "block", "important");
    const cloneRect = clone.getBoundingClientRect();
    width = cloneRect.width;
    height = cloneRect.height;
    clone.style.setProperty("display", "none");
    clone.remove();
  } else {
    width = elementRect.width;
    height = elementRect.height;
  }
  return {
    height: Math.floor(height),
    width: Math.floor(width)
  };
}

// src/utils/class_name_transformers.ts
var IDENTIFIER_REGEX = new RegExp("[_a-zA-Z]+[_a-zA-Z0-9-]*", "g");
var CLASS_NAME_REGEX = new RegExp(`\\.${IDENTIFIER_REGEX.source}`, "g");
var CONDITION_RULE_REGEX = new RegExp(`^\\s*(@(?:media|supports)[^{]*){(.*)}\\s*$`);
function transformClassSelectors(css, transform) {
  return css.replace(CLASS_NAME_REGEX, (className) => {
    return "." + transform(className.slice(1));
  });
}
function transformCSSClassRules(text, transform) {
  const sheet = createCSSStyleSheet(text);
  const rules = sheet.cssRules;
  function transformCSSRule(rule) {
    if (rule instanceof CSSStyleRule) {
      const selector = transformClassSelectors(rule.selectorText, transform);
      return `${selector} { ${rule.style.cssText} }`;
    }
    const atRule = CONDITION_RULE_REGEX.exec(rule.cssText.split("\n").join(""));
    if (atRule && atRule.length > 2) {
      const rule2 = atRule[1];
      const contents = atRule[2];
      return `${rule2} { ${transformCSSClassRules(contents, transform)} }`;
    }
    return rule.cssText;
  }
  let style = "";
  for (const rule of Array.from(rules)) {
    style += transformCSSRule(rule) + "\n\n";
  }
  return style.trim();
}
function transformDOMClassAttributes(content, transform) {
  const elements = Array.from(content.querySelectorAll("[class]"));
  elements.push(content);
  for (const element of elements) {
    const { classList } = element;
    for (const className of Array.from(classList)) {
      classList.remove(className);
      classList.add(transform(className));
    }
  }
  return content;
}

// src/utils/index.ts
var import_search_js_core = require("@mapbox/search-js-core");

// src/utils/map.ts
var FLY_TO_SPEED = 1.4;
function bboxViewport(map, bounds, delta = 0.5) {
  const { center, zoom } = map.cameraForBounds(bounds);
  const transformedZoom = Math.max(zoom - delta, 0);
  return {
    center,
    zoom: transformedZoom,
    speed: FLY_TO_SPEED
  };
}
function getMaxZoom(placeType) {
  switch (placeType) {
    case "street":
      return 15;
    case "locality":
    case "oaza":
      return 14;
    case "place":
    case "city":
      return 13;
    case "district":
      return 9;
    case "region":
    case "prefecture":
      return 6;
    case "country":
      return 4;
    default:
      return 16;
  }
}
function getStaticBaseUrl(username, styleId) {
  return `https://api.mapbox.com/styles/v1/${username}/${styleId}/static/`;
}

// src/constants.ts
var STATIC_BASE_URL_SATELLITE = getStaticBaseUrl("mapbox", "satellite-streets-v11");
var AUTOFILL_SKU_TOKEN_PREFIX = "20d01";
var MAPBOX_DOMAINS = ["mapbox.com", "mapbox.cn", "tilestream.net"];

// src/utils/index.ts
function randomValidID() {
  return `mbx` + new import_search_js_core.SessionToken().id.slice(0, 8);
}
function tryParseJSON(json) {
  try {
    return JSON.parse(json);
  } catch (e) {
    return null;
  }
}
function deepEquals(a, b) {
  if (a == null || b == null) {
    return a === b;
  }
  if (typeof a !== "object" || typeof b !== "object") {
    return a === b;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  for (const key of aKeys) {
    if (!deepEquals(a[key], b[key])) {
      return false;
    }
  }
  return true;
}
function round(num, decimalPlaces) {
  const factorOfTen = Math.pow(10, decimalPlaces);
  return Math.round(num * factorOfTen) / factorOfTen;
}
function isLocalServer(hostname) {
  return Boolean(hostname.match(/localhost|[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}|::1|\.local|^$/gi));
}
function isMapboxDomain(hostname) {
  return Boolean(MAPBOX_DOMAINS.some((domain) => hostname.includes(domain)));
}

// src/components/HTMLScopedElement.ts
var _seed, _templateUserStyleElement, _transform;
var HTMLScopedElement = class extends HTMLElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _seed, randomValidID());
    __privateAdd(this, _templateUserStyleElement, void 0);
    __privateAdd(this, _transform, (className) => {
      return `${__privateGet(this, _seed)}--${className}`;
    });
  }
  get template() {
    return null;
  }
  get templateStyle() {
    return null;
  }
  get templateUserStyle() {
    return null;
  }
  clonedCallback(oldSeed, newSeed) {
    const seedTransform = (className) => className.replace(oldSeed, newSeed);
    transformDOMClassAttributes(this, seedTransform);
    const styles = Array.from(this.querySelectorAll("style"));
    for (const style of styles) {
      style.textContent = transformClassSelectors(style.textContent, seedTransform);
    }
    if (styles.length) {
      __privateSet(this, _templateUserStyleElement, styles[styles.length - 1]);
    }
  }
  connectedCallback() {
    if (this.childElementCount > 0) {
      const oldSeed = this.dataset.seed;
      const newSeed = __privateGet(this, _seed);
      if (oldSeed && oldSeed !== newSeed) {
        this.clonedCallback(oldSeed, newSeed);
        this.dataset.seed = newSeed;
      }
      return;
    }
    this.dataset.seed = __privateGet(this, _seed);
    const template = this.template;
    if (template) {
      const element = this.prepareTemplate(template);
      this.appendChild(element);
    }
    const templateStyle = this.templateStyle;
    if (templateStyle) {
      const style = document.createElement("style");
      style.textContent = this.prepareCSS(templateStyle);
      this.appendChild(style);
    }
    const userStyle = document.createElement("style");
    if (this.templateUserStyle) {
      userStyle.textContent = this.prepareCSS(this.templateUserStyle);
    }
    this.appendChild(userStyle);
    __privateSet(this, _templateUserStyleElement, userStyle);
  }
  prepareTemplate(template) {
    const element = template.content.firstElementChild;
    return transformDOMClassAttributes(element.cloneNode(true), __privateGet(this, _transform));
  }
  prepareCSS(css) {
    return transformCSSClassRules(css, __privateGet(this, _transform));
  }
  updateTemplateUserStyle(style) {
    if (!__privateGet(this, _templateUserStyleElement)) {
      return;
    }
    __privateGet(this, _templateUserStyleElement).textContent = this.prepareCSS(style);
  }
  querySelector(selectors) {
    return super.querySelector(transformClassSelectors(selectors, __privateGet(this, _transform)));
  }
  querySelectorAll(selectors) {
    return super.querySelectorAll(transformClassSelectors(selectors, __privateGet(this, _transform)));
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return super.dispatchEvent(event);
  }
};
_seed = new WeakMap();
_templateUserStyleElement = new WeakMap();
_transform = new WeakMap();

// src/MapboxHTMLEvent.ts
var MapboxHTMLEvent = class extends CustomEvent {
  constructor(type, detail) {
    super(type, {
      composed: true,
      detail
    });
  }
  clone(newTarget) {
    const eventClone = new MapboxHTMLEvent(this.type, this.detail);
    if (newTarget) {
      Object.defineProperty(eventClone, "target", { value: newTarget });
    }
    return eventClone;
  }
};

// src/icons/close.svg
var close_default = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M3.79289 3.79289C4.18342 3.40237 4.81658 3.40237 5.20711 3.79289L9 7.58579L12.7929 3.79289C13.1834 3.40237 13.8166 3.40237 14.2071 3.79289C14.5976 4.18342 14.5976 4.81658 14.2071 5.20711L10.4142 9L14.2071 12.7929C14.5976 13.1834 14.5976 13.8166 14.2071 14.2071C13.8166 14.5976 13.1834 14.5976 12.7929 14.2071L9 10.4142L5.20711 14.2071C4.81658 14.5976 4.18342 14.5976 3.79289 14.2071C3.40237 13.8166 3.40237 13.1834 3.79289 12.7929L7.58579 9L3.79289 5.20711C3.40237 4.81658 3.40237 4.18342 3.79289 3.79289Z" fill="currentColor"/>\n</svg>';

// src/icons/question.svg
var question_default = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M9 16C12.866 16 16 12.866 16 9C16 5.13401 12.866 2 9 2C5.13401 2 2 5.13401 2 9C2 12.866 5.13401 16 9 16ZM6.88128 4.88128C7.36552 4.39704 8.02229 4.125 8.70711 4.125H9.79289C10.4777 4.125 11.1345 4.39704 11.6187 4.88128C12.103 5.36552 12.375 6.02229 12.375 6.70711V6.86762C12.375 7.8775 11.8451 8.81333 10.9792 9.33291L10.4212 9.6677C10.1547 9.82759 9.96958 10.0882 9.90264 10.3844C9.87221 10.5191 9.76307 10.6324 9.625 10.6324H8.375C8.23693 10.6324 8.12387 10.5202 8.13584 10.3826C8.21527 9.47002 8.72673 8.64354 9.52082 8.16709L10.0788 7.8323C10.4177 7.62899 10.625 7.26279 10.625 6.86762V6.70711C10.625 6.48642 10.5373 6.27477 10.3813 6.11872C10.2252 5.96267 10.0136 5.875 9.79289 5.875H8.70711C8.48642 5.875 8.27477 5.96267 8.11872 6.11872C7.96267 6.27477 7.875 6.48642 7.875 6.70711V6.8889C7.875 7.37215 7.48325 7.7639 7 7.7639C6.51675 7.7639 6.125 7.37215 6.125 6.8889V6.70711C6.125 6.02229 6.39704 5.36552 6.88128 4.88128ZM10 13C10 13.5523 9.55228 14 9 14C8.44772 14 8 13.5523 8 13C8 12.4477 8.44772 12 9 12C9.55228 12 10 12.4477 10 13Z" fill="currentColor"/>\n</svg>';

// src/icons/marker.svg
var marker_default = '<svg width="48" height="56" viewBox="0 0 48 56" fill="none" xmlns="http://www.w3.org/2000/svg">\n<g filter="url(#filter0_d_17_871)">\n<path d="M24 50.4L37.7887 36.2834C40.5158 33.6058 42.3729 30.1944 43.1253 26.4806C43.8777 22.7667 43.4915 18.9172 42.0156 15.4188C40.5397 11.9204 38.0403 8.9303 34.8336 6.82657C31.6268 4.72284 27.8567 3.59998 24 3.59998C20.1433 3.59998 16.3732 4.72284 13.1664 6.82657C9.95966 8.9303 7.4603 11.9204 5.98438 15.4188C4.50846 18.9172 4.12229 22.7667 4.87468 26.4806C5.62707 30.1944 7.48424 33.6058 10.2113 36.2834L24 50.4Z" fill="currentColor"/>\n<path d="M37.2632 35.7482L37.2576 35.7537L37.2521 35.7593L24 49.3266L10.7479 35.7593L10.7424 35.7537L10.7368 35.7482C8.11558 33.1746 6.33213 29.8974 5.60975 26.3316C4.88738 22.766 5.25802 19.07 6.6754 15.7103C8.09285 12.3505 10.4942 9.47664 13.5778 7.45367C16.6616 5.4306 20.2886 4.34998 24 4.34998C27.7114 4.34998 31.3384 5.4306 34.4222 7.45367C37.5058 9.47664 39.9072 12.3505 41.3246 15.7103C42.742 19.07 43.1126 22.766 42.3903 26.3316C41.6679 29.8974 39.8844 33.1746 37.2632 35.7482Z" stroke="white" stroke-width="1.5"/>\n</g>\n<ellipse cx="24" cy="22.45" rx="5.84999" ry="5.85" fill="white"/>\n<defs>\n<filter id="filter0_d_17_871" x="0.5" y="0.599976" width="47" height="54.8" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">\n<feFlood flood-opacity="0" result="BackgroundImageFix"/>\n<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>\n<feOffset dy="1"/>\n<feGaussianBlur stdDeviation="2"/>\n<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0"/>\n<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_17_871"/>\n<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_17_871" result="shape"/>\n</filter>\n</defs>\n</svg>';

// package.json
var version = "1.0.0-beta.9";

// src/theme.ts
var styleToggleSatelliteImg = `https://api.mapbox.com/search-js/v${version}/img/style-toggle-satellite.jpg`;
var styleToggleDefaultImg = `https://api.mapbox.com/search-js/v${version}/img/style-toggle-default.jpg`;
var MOBILE_BREAKPOINT = 768 - 1;
var MOBILE_MEDIA_QUERY = `@media only screen and (max-width: ${MOBILE_BREAKPOINT}px)`;
var DEFAULT_THEME = {
  variables: {
    unit: ["mobile", "16px", "14px"],
    unitHeader: ["mobile", "24px", "18px"],
    minWidth: "min(300px, 100vw)",
    spacing: "0.75em",
    padding: "0.5em 0.75em",
    paddingModal: "1.25em",
    colorText: "rgba(0, 0, 0, 0.75)",
    colorPrimary: "#4264FB",
    colorSecondary: "#667F91",
    colorBackground: "#fff",
    colorBackgroundHover: "#f5f5f5",
    colorBackgroundActive: "#f0f0f0",
    colorBackdrop: "rgba(102, 127, 145, 0.3)",
    border: "none",
    borderRadius: "4px",
    boxShadow: `
      0 0 10px 2px rgba(0, 0, 0, 0.05),
      0 0 6px 1px rgba(0, 0, 0, 0.1),
      0 0 0 1px rgba(0, 0, 0, 0.1)
    `,
    lineHeight: "1.2em",
    fontFamily: `
      -apple-system, BlinkMacSystemFont,
      avenir next, avenir,
      segoe ui,
      helvetica neue, helvetica,
      Ubuntu, roboto, noto, arial, sans-serif
    `,
    fontWeight: "normal",
    fontWeightSemibold: "600",
    fontWeightBold: "bold",
    duration: "150ms",
    curve: "ease-out"
  },
  icons: {
    close: close_default,
    question: question_default,
    marker: marker_default
  },
  images: {
    styleToggleDefault: styleToggleDefaultImg,
    styleToggleSatellite: styleToggleSatelliteImg
  }
};
function getThemeCSS(rootSelector, theme = {}) {
  const variables = __spreadValues(__spreadValues({}, DEFAULT_THEME.variables), theme.variables || {});
  let cssText = theme.cssText || "";
  let rootVariables = "";
  for (const [key, value] of Object.entries(variables)) {
    if (!Array.isArray(value)) {
      rootVariables += `--${key}: ${value};`;
      continue;
    }
    if (value[0] !== "mobile") {
      const valueStr = JSON.stringify(value);
      throw new Error(`Unsupported expression in theme variables: ${key} ${valueStr}`);
    }
    const [, mobileValue, desktopValue] = value;
    cssText += `${MOBILE_MEDIA_QUERY} { ${rootSelector} { --${key}: ${mobileValue} !important; } }`;
    rootVariables += `--${key}: ${desktopValue};`;
  }
  return cssText + `${rootSelector} { ${rootVariables} }`;
}
function getIcon(iconName, theme = {}) {
  const icons = __spreadValues(__spreadValues({}, DEFAULT_THEME.icons), theme.icons || {});
  const svgString = icons[iconName];
  return svgString;
}
function getImage(imageName, theme = {}) {
  const images = __spreadValues(__spreadValues({}, DEFAULT_THEME.images), theme.images || {});
  const imgString = images[imageName];
  return imgString;
}

// src/style.css
var style_default = "*{box-sizing:border-box!important}[role=button]{cursor:pointer}.MapboxSearch{--width:0;display:none}.Results{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);margin-top:var(--spacing)!important;min-width:var(--minWidth);overflow-y:auto;position:absolute;transform:translateZ(0);transition:visibility var(--duration);width:var(--width);z-index:1000}.Results:not([aria-hidden=true]){visibility:visible}.Results[aria-hidden=true]{animation:fadein var(--duration) var(--curve) reverse forwards;visibility:hidden}.Suggestion{padding:var(--padding)}.Suggestion:hover{cursor:pointer}.Suggestion[aria-selected=true]{background-color:var(--colorBackgroundHover)}.Suggestion:active{background-color:var(--colorBackgroundActive)}.SuggestionName{font-weight:var(--fontWeightBold)}.ResultsAttribution{padding:var(--padding)}.ResultsAttribution a{color:var(--colorSecondary)}.ResultsAttribution a:not(:hover){text-decoration:none}.ResultsList{list-style:none;margin:0;padding:0}.Label{display:none}.Input{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);padding:var(--padding);width:100%}mapbox-address-confirmation-feature[aria-hidden=true],mapbox-address-confirmation-no-feature[aria-hidden=true]{display:none}.MapboxAddressConfirmation{align-items:center;background-color:var(--colorBackdrop);bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;transform:translateZ(0);z-index:1000}.MapboxAddressConfirmation:not([aria-hidden=true]){animation:fadein var(--duration) var(--curve) forwards;visibility:visible}.MapboxAddressConfirmation[aria-hidden=true]{visibility:hidden}.ContentFeature,.ContentNoFeature{width:var(--minWidth)}.Modal{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);padding:var(--paddingModal);width:100%}@media screen and (max-width:480px){.MapboxAddressConfirmation{align-items:flex-end}.ContentFeature,.ContentNoFeature{width:100%}.Modal{border-bottom-left-radius:0;border-bottom-right-radius:0}}.ModalHeader{align-items:center;color:var(--colorPrimary);display:flex;font-size:var(--unitHeader);font-weight:var(--fontWeightBold);margin-bottom:var(--spacing);user-select:none;width:100%}.ModalMap{height:calc(var(--minWidth)*9/16);margin-left:calc(var(--paddingModal)*-1);width:calc(100% + var(--paddingModal)*2)}.ModalMap[aria-hidden=true]{display:none}.Icon{height:var(--unitHeader);width:var(--unitHeader)}.Icon.IconClose{color:var(--colorSecondary)}.ModalHeaderTitle{flex:1;margin-left:.25em}.ModalFooter{color:var(--colorSecondary);margin-top:var(--spacing);text-align:center}.ModalSubheader{font-weight:var(--fontWeightBold);user-select:none}.ModalDescription{color:var(--colorPrimary)}.ModalAddress,.ModalSubheader{margin-bottom:var(--spacing)}.ModalAddress.ModalAddressApprove{color:var(--colorPrimary)}.Button{border-radius:var(--borderRadius);cursor:pointer;font-weight:var(--fontWeightSemibold);margin-top:var(--spacing);padding:var(--padding);text-align:center;user-select:none;width:100%}.Button[aria-hidden=true]{display:none}.Button.ButtonPrimary{background-color:var(--colorPrimary);color:var(--colorBackground)}.Button.ButtonSecondary{border:1px solid var(--colorSecondary);color:var(--colorSecondary)}@keyframes fadein{0%{opacity:0}to{opacity:1}}.MapboxAddressMinimap{font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight)}.MapboxAddressMinimap[aria-hidden=true]{display:none}.MinimapImageContainer{border-radius:var(--borderRadius);overflow:hidden}.MinimapImage{height:unset;max-height:unset;max-width:unset;position:relative;width:unset}.MinimapInnerFrame{border:var(--border);border-radius:inherit;height:inherit;left:0;overflow:hidden;position:absolute;top:0;width:inherit}.MinimapMarker{left:50%;position:absolute;top:50%}.MinimapMarker>svg{color:var(--colorPrimary);display:block!important}.MinimapAttributionLogo{bottom:0;left:0;margin:0 0 6px 6px;position:absolute}.MinimapAttributionLogo a{cursor:pointer;display:block;height:23px;width:88px}.MinimapAttributionText{background-color:hsla(0,0%,100%,.65);bottom:0;font:11px/16px Helvetica Neue,Arial,Helvetica,sans-serif;padding:0 5px;position:absolute;right:0}.MinimapAttributionText a{color:rgba(0,0,0,.75);text-decoration:none}.MinimapAttributionText a:hover{color:inherit;text-decoration:underline}.MinimapAttributionText a:not(:first-child){margin-left:3px}.MinimapStyleToggle{background-position:0;background-repeat:no-repeat;background-size:contain;border:2px solid #fff;border-radius:3px;box-shadow:var(--boxShadow);cursor:pointer;height:2em;position:absolute;right:var(--spacing);top:var(--spacing);width:2em}.MinimapFooter{color:var(--colorSecondary);font-family:var(--fontFamily);font-size:var(--unit);margin-top:var(--spacing)}.MinimapEditButtons{bottom:26px;display:flex;font-family:var(--fontFamily);position:absolute;right:var(--spacing)}.MinimapEditButtons .Button{box-shadow:var(--boxShadow)}.MinimapButtonCancel{background-color:var(--colorBackground);margin-left:var(--spacing)}.draggable{cursor:move;cursor:grab}.draggable:active{cursor:grabbing}";

// src/components/MapboxSearchListbox.ts
var TEMPLATE = createElementFromString(`
<template>
  <div class="MapboxSearch">
      <div class="Label" role="label" aria-live="polite" aria-atomic="true">
      </div>
      <div class="Results" aria-hidden="true">
        <div class="ResultsList" role="listbox">
        </div>
        <div class="ResultsAttribution" aria-hidden="true">
          <a href="https://www.mapbox.com/search-service" target="_blank" tabindex="-1">
            Powered by Mapbox
          </a>
        </div>
      </div>
  </div>
</template>
`);
var RENDER_TEMPLATE = createElementFromString(`
<template>
  <div class="Suggestion" role="option">
    <div class="SuggestionName"></div>
    <div class="SuggestionDesc"></div>
  </div>
</template>
`);
function getAriaIdForSuggestion(resultListId, i) {
  return `${resultListId}-${i}`;
}
var _sessionInternal, _popper, _binding, _labelID, _resultListID, _inputInternal, _selectedIndexInternal, _showResults, showResults_fn, _hideResults, hideResults_fn, _renderResultsList, renderResultsList_fn, _optionsInternal, _themeInternal, _handleInput, _handleSuggest, _handleSuggestError, _handleFocus, _handleBlur, _handleKeyDown;
var MapboxSearchListbox = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _showResults);
    __privateAdd(this, _hideResults);
    __privateAdd(this, _renderResultsList);
    __privateAdd(this, _sessionInternal, void 0);
    __privateAdd(this, _popper, null);
    __privateAdd(this, _binding, void 0);
    __privateAdd(this, _labelID, randomValidID());
    __privateAdd(this, _resultListID, randomValidID());
    __privateAdd(this, _inputInternal, void 0);
    __privateAdd(this, _selectedIndexInternal, 0);
    __privateAdd(this, _optionsInternal, {});
    __privateAdd(this, _themeInternal, {});
    this.retrieveFeature = null;
    __privateAdd(this, _handleInput, (e) => {
      const { Results } = __privateGet(this, _binding);
      const input = e.target;
      if (input.dataset["mapboxSuccess"]) {
        delete input.dataset["mapboxSuccess"];
        return;
      }
      const searchText = input.value;
      Results.setAttribute("aria-busy", "true");
      this.session.suggest(searchText, this.options);
    });
    __privateAdd(this, _handleSuggest, (result) => {
      if (!result || !result.suggestions) {
        __privateMethod(this, _hideResults, hideResults_fn).call(this);
        return;
      }
      __privateMethod(this, _renderResultsList, renderResultsList_fn).call(this);
      if (result.suggestions.length) {
        __privateMethod(this, _showResults, showResults_fn).call(this);
      }
      this.dispatchEvent(new MapboxHTMLEvent("suggest", result));
      const { Results } = __privateGet(this, _binding);
      Results.setAttribute("aria-busy", "false");
    });
    __privateAdd(this, _handleSuggestError, (error) => {
      this.dispatchEvent(new MapboxHTMLEvent("suggesterror", error));
      const { Results } = __privateGet(this, _binding);
      Results.setAttribute("aria-busy", "false");
      __privateMethod(this, _hideResults, hideResults_fn).call(this);
    });
    __privateAdd(this, _handleFocus, () => {
      const input = this.input;
      delete input.dataset["mapboxSuccess"];
      __privateMethod(this, _showResults, showResults_fn).call(this);
    });
    __privateAdd(this, _handleBlur, () => {
      if (document.activeElement === this.input) {
        return;
      }
      this.session.abort();
      __privateMethod(this, _hideResults, hideResults_fn).call(this);
    });
    __privateAdd(this, _handleKeyDown, (e) => {
      if (e.key === "Escape") {
        __privateMethod(this, _hideResults, hideResults_fn).call(this);
        return;
      }
      if (e.key === "ArrowUp") {
        e.preventDefault();
        this.selectedIndex = Math.max(0, this.selectedIndex - 1);
        return;
      }
      if (e.key === "ArrowDown") {
        e.preventDefault();
        this.selectedIndex = Math.min(this.selectedIndex + 1, this.suggestions.length - 1);
        return;
      }
      if (e.key === "Enter") {
        e.preventDefault();
        this.retrieve(this.suggestions[this.selectedIndex]);
        return;
      }
    });
  }
  get template() {
    return TEMPLATE;
  }
  get templateStyle() {
    return style_default;
  }
  get templateUserStyle() {
    return getThemeCSS(".MapboxSearch", this.theme);
  }
  get session() {
    return __privateGet(this, _sessionInternal);
  }
  set session(newSession) {
    const oldSession = __privateGet(this, _sessionInternal);
    if (oldSession) {
      newSession.removeEventListener("suggest", __privateGet(this, _handleSuggest));
      newSession.removeEventListener("suggesterror", __privateGet(this, _handleSuggestError));
    }
    if (newSession) {
      newSession.addEventListener("suggest", __privateGet(this, _handleSuggest));
      newSession.addEventListener("suggesterror", __privateGet(this, _handleSuggestError));
    }
    __privateSet(this, _sessionInternal, newSession);
  }
  get suggestions() {
    var _a;
    return (_a = this.session.suggestions) == null ? void 0 : _a.suggestions;
  }
  get input() {
    return __privateGet(this, _inputInternal);
  }
  set input(newInput) {
    const oldInput = __privateGet(this, _inputInternal);
    if (oldInput) {
      oldInput.removeEventListener("input", __privateGet(this, _handleInput));
      oldInput.removeEventListener("focus", __privateGet(this, _handleFocus));
      oldInput.removeEventListener("blur", __privateGet(this, _handleBlur));
      oldInput.removeEventListener("keydown", __privateGet(this, _handleKeyDown));
      if (__privateGet(this, _popper)) {
        __privateGet(this, _popper).destroy();
      }
    }
    if (newInput) {
      newInput.addEventListener("input", __privateGet(this, _handleInput));
      newInput.addEventListener("focus", __privateGet(this, _handleFocus));
      newInput.addEventListener("blur", __privateGet(this, _handleBlur));
      newInput.addEventListener("keydown", __privateGet(this, _handleKeyDown));
      newInput.setAttribute("role", "combobox");
      newInput.setAttribute("aria-autocomplete", "list");
      newInput.setAttribute("aria-controls", __privateGet(this, _resultListID));
      if (this.isConnected) {
        __privateSet(this, _popper, (0, import_popper_lite.createPopper)(newInput, __privateGet(this, _binding).Results, {
          placement: "bottom-start"
        }));
      }
    }
    __privateSet(this, _inputInternal, newInput);
  }
  get selectedIndex() {
    return __privateGet(this, _selectedIndexInternal);
  }
  set selectedIndex(newIndex) {
    const oldIndex = __privateGet(this, _selectedIndexInternal);
    __privateSet(this, _selectedIndexInternal, newIndex);
    const { ResultsList, Label } = __privateGet(this, _binding);
    const id = getAriaIdForSuggestion(__privateGet(this, _resultListID), newIndex);
    this.input.setAttribute("aria-activedescendant", id);
    ResultsList.setAttribute("aria-activedescendant", id);
    if (oldIndex !== newIndex) {
      const oldId = getAriaIdForSuggestion(__privateGet(this, _resultListID), oldIndex);
      const oldEl = ResultsList.querySelector(`#${oldId}`);
      oldEl == null ? void 0 : oldEl.removeAttribute("aria-selected");
      const el = ResultsList.querySelector(`#${id}`);
      el == null ? void 0 : el.setAttribute("aria-selected", "true");
    }
    Label.textContent = this.suggestions[newIndex].address + `: Suggestion ${newIndex + 1} of ${this.suggestions.length}`;
  }
  renderItem(i) {
    const element = this.prepareTemplate(RENDER_TEMPLATE);
    element.id = getAriaIdForSuggestion(__privateGet(this, _resultListID), i);
    return element;
  }
  fillItem(el, item, i) {
    const [nameEl, descriptionEl] = Array.from(el.querySelectorAll('[role="option"] > *'));
    nameEl.textContent = "address_line1" in item ? item.address_line1 || item.matching_name || item.feature_name : item.matching_name || item.feature_name;
    descriptionEl.textContent = item.description;
    if (i === this.selectedIndex) {
      el.setAttribute("aria-selected", "true");
    } else {
      el.removeAttribute("aria-selected");
    }
  }
  get options() {
    return __privateGet(this, _optionsInternal);
  }
  set options(newOptions) {
    __privateSet(this, _optionsInternal, newOptions);
  }
  get theme() {
    return __privateGet(this, _themeInternal);
  }
  set theme(theme) {
    __privateSet(this, _themeInternal, theme);
    if (!__privateGet(this, _binding) || !theme) {
      return;
    }
    this.updateTemplateUserStyle(getThemeCSS(".MapboxSearch", theme));
  }
  connectedCallback() {
    super.connectedCallback();
    __privateSet(this, _binding, bindElements(this, {
      MapboxSearch: ".MapboxSearch",
      Results: ".Results",
      ResultsList: ".ResultsList",
      Label: ".Label"
    }));
    const { Results, ResultsList, Label } = __privateGet(this, _binding);
    Label.id = __privateGet(this, _labelID);
    ResultsList.id = __privateGet(this, _resultListID);
    ResultsList.setAttribute("aria-labelledby", __privateGet(this, _labelID));
    Results.addEventListener("blur", __privateGet(this, _handleBlur));
    if (!__privateGet(this, _popper) && this.input) {
      __privateSet(this, _popper, (0, import_popper_lite.createPopper)(this.input, __privateGet(this, _binding).Results, {
        placement: "bottom-start"
      }));
    }
    requestAnimationFrame(() => {
      if (__privateGet(this, _popper)) {
        __privateGet(this, _popper).update();
      }
    });
  }
  disconnectedCallback() {
    this.input = null;
    const { Results } = __privateGet(this, _binding);
    Results.removeEventListener("blur", __privateGet(this, _handleBlur));
  }
  retrieve(suggestion) {
    return __async(this, null, function* () {
      var _a;
      const input = this.input;
      if (input) {
        input.dataset["mapboxSuccess"] = "true";
      }
      const result = yield this.session.retrieve(suggestion, this.options);
      this.retrieveFeature = (_a = result.features) == null ? void 0 : _a[0];
      __privateMethod(this, _hideResults, hideResults_fn).call(this);
      this.dispatchEvent(new MapboxHTMLEvent("retrieve", result));
    });
  }
  focus() {
    if (document.activeElement === this.input) {
      __privateGet(this, _handleFocus).call(this);
    } else {
      this.input.focus();
    }
  }
  updatePopover() {
    if (__privateGet(this, _popper)) {
      __privateGet(this, _popper).update();
    }
  }
};
_sessionInternal = new WeakMap();
_popper = new WeakMap();
_binding = new WeakMap();
_labelID = new WeakMap();
_resultListID = new WeakMap();
_inputInternal = new WeakMap();
_selectedIndexInternal = new WeakMap();
_showResults = new WeakSet();
showResults_fn = function() {
  if (!this.suggestions || !this.suggestions.length) {
    return;
  }
  const { Results, MapboxSearch: MapboxSearch2 } = __privateGet(this, _binding);
  const rect = this.input.getBoundingClientRect();
  MapboxSearch2.style.setProperty("--width", `${rect.width}px`);
  MapboxSearch2.style.setProperty("display", "block");
  this.input.setAttribute("aria-expanded", "true");
  Results.removeAttribute("aria-hidden");
  this.selectedIndex = 0;
};
_hideResults = new WeakSet();
hideResults_fn = function() {
  const { Results, ResultsList } = __privateGet(this, _binding);
  Results.setAttribute("aria-hidden", "true");
  this.input.removeAttribute("aria-expanded");
  ResultsList.removeAttribute("aria-activedescendant");
  this.input.removeAttribute("aria-activedescendant");
};
_renderResultsList = new WeakSet();
renderResultsList_fn = function() {
  const { ResultsList } = __privateGet(this, _binding);
  const suggestions = this.suggestions;
  if (!suggestions || !suggestions.length) {
    ResultsList.innerHTML = "";
    __privateMethod(this, _hideResults, hideResults_fn).call(this);
    return;
  }
  const elements = getChildElements(ResultsList);
  if (suggestions.length > elements.length) {
    for (let i = elements.length; i < suggestions.length; i++) {
      const item = this.renderItem(i);
      elements.push(item);
      item.onmouseenter = () => {
        this.selectedIndex = i;
      };
      ResultsList.appendChild(item);
    }
  }
  if (suggestions.length < elements.length) {
    for (let i = suggestions.length; i < elements.length; i++) {
      elements[i].remove();
    }
  }
  for (const suggestion of suggestions) {
    const i = suggestions.indexOf(suggestion);
    const element = elements[i];
    this.fillItem(element, suggestion, i);
    element.onclick = () => {
      this.retrieve(suggestion);
    };
  }
};
_optionsInternal = new WeakMap();
_themeInternal = new WeakMap();
_handleInput = new WeakMap();
_handleSuggest = new WeakMap();
_handleSuggestError = new WeakMap();
_handleFocus = new WeakMap();
_handleBlur = new WeakMap();
_handleKeyDown = new WeakMap();
window.MapboxSearchListbox = MapboxSearchListbox;
if (!window.customElements.get("mapbox-search-listbox")) {
  customElements.define("mapbox-search-listbox", MapboxSearchListbox);
}

// src/utils/aria.ts
function ariaButtonKeyDown(e) {
  const el = e.currentTarget;
  if (e.key === " " || e.key === "Enter") {
    e.preventDefault();
    e.stopPropagation();
    el.dispatchEvent(new MouseEvent("click", {
      bubbles: true,
      composed: true
    }));
  }
}

// src/utils/autofill.ts
var import_search_js_core2 = require("@mapbox/search-js-core");
var AUTOFILL_TOKENS = /* @__PURE__ */ new Set([
  "street-address",
  "address-line1",
  "address-line2",
  "address-line3",
  "address-level4",
  "address-level3",
  "address-level2",
  "address-level1",
  "country",
  "country-name",
  "postal-code"
]);
var AUTOFILL_SKIP_TOKENS = /* @__PURE__ */ new Set(["off", "on", "true", "false"]);
function findParentForm(el) {
  let node = el.parentNode;
  while (node) {
    if (node instanceof HTMLFormElement) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
}
function findAddressInputs(form) {
  const parent = form || document;
  return Array.from(parent.querySelectorAll('input[autocomplete~="address-line1"], input[autocomplete~="street-address"]'));
}
var SECTION = "section-";
var SECTION_DEFAULT = "section-default";
var SECTION_SHIPPING = "section-shipping";
var SECTION_BILLING = "section-billing";
function parseFormStructure(form) {
  const inputs = Array.from(form.querySelectorAll("[autocomplete]")).filter((el) => {
    const tagName = el.tagName.toLowerCase();
    return tagName === "input" || tagName === "select" || tagName === "textarea";
  });
  const res = [];
  for (const input of inputs) {
    if (!isVisible(input)) {
      continue;
    }
    const autocomplete = input.getAttribute("autocomplete") || "";
    if (!autocomplete || AUTOFILL_SKIP_TOKENS.has(autocomplete)) {
      continue;
    }
    const tokens = autocomplete.toLowerCase().split(" ");
    if (tokens.length > 3) {
      continue;
    }
    const field = tokens[tokens.length - 1];
    if (!AUTOFILL_TOKENS.has(field)) {
      continue;
    }
    tokens.pop();
    let section = SECTION_DEFAULT;
    if (tokens.length) {
      const sectionToken = tokens[tokens.length - 1];
      if (sectionToken === "shipping") {
        section = SECTION_SHIPPING;
        tokens.pop();
      }
      if (sectionToken === "billing") {
        section = SECTION_BILLING;
        tokens.pop();
      }
    }
    if (tokens.length) {
      const sectionToken = tokens[tokens.length - 1];
      if (sectionToken.startsWith(SECTION)) {
        section = sectionToken;
      }
    }
    res.push({
      input,
      section,
      field
    });
  }
  return res;
}
function findAddressAutofillInputs(form, ref) {
  const logicalSections = [];
  const logicalSectionSections = [];
  const formStructure = parseFormStructure(form);
  let foundSection = null;
  for (const { input, section, field } of formStructure) {
    let lastIndex = logicalSections.length - 1;
    let createNewSection = false;
    if (!logicalSections.length) {
      createNewSection = true;
    } else if (logicalSectionSections[lastIndex] !== section) {
      createNewSection = true;
    } else if (logicalSections[lastIndex][field]) {
      createNewSection = true;
    }
    if (createNewSection) {
      if (foundSection) {
        break;
      }
      logicalSections.push({
        [field]: input
      });
      logicalSectionSections.push(section);
      lastIndex++;
    } else {
      logicalSections[lastIndex][field] = input;
    }
    if (input === ref) {
      foundSection = logicalSections[lastIndex];
    }
  }
  return foundSection != null ? foundSection : {};
}
function setFormAutofillValues(form, ref, suggestion) {
  var _a;
  const map = findAddressAutofillInputs(form, ref);
  const streetAddress = [
    suggestion.address_line1,
    suggestion.address_line2,
    suggestion.address_line3
  ].filter((part) => Boolean(part)).join(", ");
  setValue(map["street-address"], streetAddress);
  setValue(map["address-line1"], suggestion.address_line1 || "");
  setValue(map["address-level1"], suggestion.address_level1 || "");
  setValue(map["address-level2"], suggestion.address_level2 || "");
  setValue(map["address-level3"], suggestion.address_level3 || "");
  const countryCode = ((_a = suggestion.metadata) == null ? void 0 : _a.iso_3166_1) || "";
  if (map.country && map.country instanceof HTMLSelectElement) {
    const firstOption = map.country.querySelector(`option`).value;
    const isUpperCase = firstOption === firstOption.toUpperCase();
    setValue(map["country"], isUpperCase ? countryCode.toUpperCase() : countryCode);
  } else {
    setValue(map["country"], countryCode);
  }
  setValue(map["country-name"], suggestion.country || "");
  setValue(map["postal-code"], suggestion.postcode || "");
}
function getFormAutofillValues(form, ref) {
  const map = findAddressAutofillInputs(form, ref);
  const values = {};
  for (const [key, input] of Object.entries(map)) {
    if (input == null ? void 0 : input.value) {
      values[key] = input.value;
    }
  }
  return values;
}
function getAutofillSearchText(snapshot) {
  const searchText = [];
  if (snapshot["street-address"]) {
    searchText.push(snapshot["street-address"]);
  } else {
    searchText.push(snapshot["address-line1"] || "");
    searchText.push(snapshot["address-line2"] || "");
    searchText.push(snapshot["address-line3"] || "");
  }
  searchText.push(snapshot["address-level3"] || "");
  searchText.push(snapshot["address-level2"] || "");
  searchText.push(snapshot["address-level1"] || "");
  searchText.push(snapshot["postal-code"] || "");
  if (snapshot["country-name"]) {
    searchText.push(snapshot["country-name"]);
  } else {
    searchText.push(snapshot["country"] || "");
  }
  return searchText.filter((part) => Boolean(part)).join(", ");
}
function fillFormWithFeature(feature, input) {
  const form = findParentForm(input);
  if (!form) {
    return;
  }
  const suggestion = (0, import_search_js_core2.featureToSuggestion)(feature);
  setFormAutofillValues(form, input, suggestion);
}
function featureToAutofillValueMap(feature) {
  var _a;
  const values = {};
  const streetAddress = [
    feature.properties.address_line1,
    feature.properties.address_line2,
    feature.properties.address_line3
  ].filter((part) => Boolean(part)).join(", ");
  values["street-address"] = streetAddress;
  values["address-line1"] = feature.properties.address_line1;
  values["address-line2"] = feature.properties.address_line2;
  values["address-line3"] = feature.properties.address_line3;
  values["address-level1"] = feature.properties.address_level1;
  values["address-level2"] = feature.properties.address_level2;
  values["address-level3"] = feature.properties.address_level3;
  values["country"] = (_a = feature.properties.metadata) == null ? void 0 : _a.iso_3166_1;
  values["country-name"] = feature.properties.country;
  values["postal-code"] = feature.properties.postcode;
  return values;
}
function checkAutofillValuesChanged(targetMap, referenceMap) {
  for (const [key, value] of Object.entries(targetMap)) {
    if (referenceMap[key] !== value)
      return true;
  }
  return false;
}

// src/utils/confirmation.ts
function createAddressElement(autofillValues, baseAddress) {
  if (baseAddress) {
    const element = createElementFromString(`
        <span>
          <span></span>
          <br />
          <span></span>
        </span>
      `);
    const [firstLine, lastLine] = Array.from(element.querySelectorAll("span > span"));
    const parts = baseAddress.split(",");
    firstLine.textContent = parts[0].trim();
    lastLine.textContent = parts.slice(1).join(",").trim();
    if (autofillValues["address-line2"]) {
      const span = document.createElement("span");
      span.textContent = autofillValues["address-line2"];
      element.insertBefore(span, lastLine);
      element.insertBefore(document.createElement("br"), lastLine);
    }
    if (autofillValues["address-line3"]) {
      const span = document.createElement("span");
      span.textContent = autofillValues["address-line3"];
      element.insertBefore(span, lastLine);
      element.insertBefore(document.createElement("br"), lastLine);
    }
    return element;
  } else {
    const firstLine = autofillValues["street-address"] || autofillValues["address-line1"] || "";
    const line2 = autofillValues["address-line2"];
    const line3 = autofillValues["address-line3"];
    const lastLine = [
      autofillValues["address-level4"] || "",
      autofillValues["address-level3"] || "",
      autofillValues["address-level2"] || "",
      `${autofillValues["address-level1"] || ""} ${autofillValues["postal-code"] || ""}`,
      autofillValues.country || autofillValues["country-name"] || ""
    ].filter(Boolean).join(", ");
    const addressLines = [firstLine, line2, line3, lastLine].filter(Boolean);
    const addressLinesHtml = addressLines.map((val) => `<span>${val}</span>`).join("<br />");
    const element = createElementFromString(`
        <span>${addressLinesHtml}</span>
      `);
    return element;
  }
}

// src/config.ts
var import_search_js_core3 = require("@mapbox/search-js-core");
var Config = class {
  constructor() {
    this.feedbackEnabled = true;
    this.autofillSessionToken = new import_search_js_core3.SessionToken();
    this.autofillSessionEnabled = false;
  }
};
var config = new Config();
Object.defineProperty(config, "autofillSessionToken", {
  configurable: false,
  writable: false
});

// src/utils/contribute.ts
var CONTRIBUTE_API_BASE_URL = "https://contribute-api.mapbox.com/v1";
var CONTRIBUTE_API_STAGING_BASE_URL = "https://contribute-api-staging.tilestream.net/v1";
var EDIT_SUGGESTION_ENDPOINT = "edit-suggestion";
function sendFeedback(accessToken, feedbackArgs) {
  if (!config.feedbackEnabled)
    return;
  const hostname = window.location.hostname;
  const BASE_URL = isLocalServer(hostname) || isMapboxDomain(hostname) ? CONTRIBUTE_API_STAGING_BASE_URL : CONTRIBUTE_API_BASE_URL;
  const url = `${BASE_URL}/${EDIT_SUGGESTION_ENDPOINT}/address?access_token=${accessToken}`;
  const { originalCoordinate, originalAddress, changes } = feedbackArgs;
  const payload = {
    action: "update",
    reason: "incorrect_address",
    location: {
      longitude: originalCoordinate[0],
      latitude: originalCoordinate[1]
    },
    userEmail: "no-reply-autofill@mapbox.com",
    changes,
    placeName: originalAddress
  };
  fetch(url, {
    method: "POST",
    headers: new Headers({
      "User-Agent": `mapbox-search-js.${version}.${navigator.userAgent}`,
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(payload)
  });
}

// src/components/MapboxAddressConfirmationFeature.ts
var TEMPLATE2 = createElementFromString(`
<template>
  <div class="MapboxAddressConfirmationFeature">
    <div class="Modal" aria-modal="true" role="dialog">
      <div class="ModalHeader">
        <svg viewBox="0 0 18 18" class="Icon IconQuestion"></svg>
        <div class="ModalHeaderTitle">Did you mean?</div>
        <svg
          viewBox="0 0 18 18"
          class="Icon IconClose"
          tabindex="0"
          role="button"
          title="Close"
          aria-label="Close"
          aria-expanded="true"
        ></svg>
      </div>

      <div class="ModalAddress ModalAddressApprove"></div>
            
      <div class="ModalMap">
        <mapbox-address-minimap class="Minimap"></mapbox-address-minimap>
      </div>

      <div
        class="Button ButtonPrimary ButtonApprove"
        tabindex="0"
        role="button"
        aria-label="Yes"
      >
        Yes
      </div>
      
      <div
        class="Button ButtonSecondary ButtonReject"
        tabindex="0"
        role="button"
        aria-label="No, use the address I provided"
      >
        No, use the address I provided
      </div>

      <div class="ModalFooter">
          Your confirmation helps ensure your order is delivered correctly.
      </div>
    </div>
  </div>
</template>
`);
var _binding2, _themeInternal2, _feature, _formValues, _handleClose, _modalID, _modalHeaderTitleID, _modalAddressApproveID;
var MapboxAddressConfirmationFeature = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _binding2, void 0);
    __privateAdd(this, _themeInternal2, {});
    this.minimap = false;
    __privateAdd(this, _feature, void 0);
    __privateAdd(this, _formValues, void 0);
    this.update = (feature, autofillValues) => {
      __privateSet(this, _feature, feature);
      __privateSet(this, _formValues, autofillValues);
      const { ModalMap, Minimap, ModalAddressApprove } = __privateGet(this, _binding2);
      if (this.minimap) {
        ModalMap.removeAttribute("aria-hidden");
        Minimap.accessToken = this.accessToken;
        if (typeof this.minimap === "object") {
          const { defaultMapStyle, theme, mapStyleMode, satelliteToggle } = this.minimap;
          defaultMapStyle && (Minimap.defaultMapStyle = this.minimap.defaultMapStyle);
          theme && (Minimap.theme = this.minimap.theme);
          mapStyleMode && (Minimap.mapStyleMode = mapStyleMode);
          satelliteToggle !== void 0 && (Minimap.satelliteToggle = satelliteToggle);
        }
        Minimap.feature = feature;
      } else {
        ModalMap.setAttribute("aria-hidden", "true");
      }
      const approveAddress = feature.properties.place_name || feature.properties.full_address || feature.properties.address;
      ModalAddressApprove.innerHTML = "";
      ModalAddressApprove.appendChild(createAddressElement(autofillValues, approveAddress));
    };
    __privateAdd(this, _handleClose, () => {
      this.dispatchEvent(new MapboxHTMLEvent("result", "cancel"));
    });
    this.approve = () => {
      this.dispatchEvent(new MapboxHTMLEvent("result", "change"));
    };
    this.reject = () => {
      this.dispatchEvent(new MapboxHTMLEvent("result", "nochange"));
      sendFeedback(this.accessToken, {
        originalCoordinate: __privateGet(this, _feature).geometry.coordinates,
        originalAddress: __privateGet(this, _feature).properties.full_address,
        changes: {
          address: getAutofillSearchText(__privateGet(this, _formValues))
        }
      });
    };
    __privateAdd(this, _modalID, randomValidID());
    __privateAdd(this, _modalHeaderTitleID, randomValidID());
    __privateAdd(this, _modalAddressApproveID, randomValidID());
  }
  get template() {
    return TEMPLATE2;
  }
  get templateStyle() {
    return style_default;
  }
  get templateUserStyle() {
    return getThemeCSS(".MapboxAddressConfirmationFeature", this.theme);
  }
  get theme() {
    return __privateGet(this, _themeInternal2);
  }
  set theme(theme) {
    __privateSet(this, _themeInternal2, theme);
    if (!__privateGet(this, _binding2) || !theme) {
      return;
    }
    this.updateTemplateUserStyle(getThemeCSS(".MapboxAddressConfirmationFeature", theme));
    const { IconQuestion, IconClose } = __privateGet(this, _binding2);
    IconQuestion.innerHTML = getIcon("question", theme);
    IconClose.innerHTML = getIcon("close", theme);
  }
  connectedCallback() {
    super.connectedCallback();
    __privateSet(this, _binding2, bindElements(this, {
      MapboxAddressConfirmationFeature: ".MapboxAddressConfirmationFeature",
      Modal: ".Modal",
      ModalHeaderTitle: ".ModalHeaderTitle",
      ModalMap: ".ModalMap",
      Minimap: ".Minimap",
      IconQuestion: ".IconQuestion",
      IconClose: ".IconClose",
      ButtonApprove: ".ButtonApprove",
      ButtonReject: ".ButtonReject",
      ModalAddressApprove: ".ModalAddressApprove"
    }));
    const {
      Modal,
      ModalHeaderTitle,
      IconClose,
      ButtonApprove,
      ButtonReject,
      ModalAddressApprove
    } = __privateGet(this, _binding2);
    Modal.setAttribute("aria-labelledby", __privateGet(this, _modalHeaderTitleID));
    Modal.setAttribute("aria-describedby", __privateGet(this, _modalAddressApproveID));
    IconClose.setAttribute("aria-controls", __privateGet(this, _modalID));
    Modal.id = __privateGet(this, _modalID);
    ModalHeaderTitle.id = __privateGet(this, _modalHeaderTitleID);
    ModalAddressApprove.id = __privateGet(this, _modalAddressApproveID);
    const buttons = Array.from(this.querySelectorAll('[role="button"]'));
    for (const button of buttons) {
      button.addEventListener("keydown", ariaButtonKeyDown);
    }
    IconClose.addEventListener("click", __privateGet(this, _handleClose));
    ButtonApprove.addEventListener("click", this.approve);
    ButtonReject.addEventListener("click", this.reject);
    const theme = this.theme;
    if (theme) {
      const { IconQuestion, IconClose: IconClose2 } = __privateGet(this, _binding2);
      IconQuestion.innerHTML = getIcon("question", theme);
      IconClose2.innerHTML = getIcon("close", theme);
    }
  }
  disconnectedCallback() {
    const { IconClose, ButtonApprove } = __privateGet(this, _binding2);
    IconClose.removeEventListener("click", __privateGet(this, _handleClose));
    ButtonApprove.removeEventListener("click", this.approve);
  }
};
_binding2 = new WeakMap();
_themeInternal2 = new WeakMap();
_feature = new WeakMap();
_formValues = new WeakMap();
_handleClose = new WeakMap();
_modalID = new WeakMap();
_modalHeaderTitleID = new WeakMap();
_modalAddressApproveID = new WeakMap();
window.MapboxAddressConfirmationFeature = MapboxAddressConfirmationFeature;
if (!window.customElements.get("mapbox-address-confirmation-feature")) {
  customElements.define("mapbox-address-confirmation-feature", MapboxAddressConfirmationFeature);
}

// src/components/MapboxAddressConfirmationNoFeature.ts
var TEMPLATE3 = createElementFromString(`
<template>
  <div class="MapboxAddressConfirmationNoFeature">
    <div class="Modal" aria-modal="true" role="dialog">
      <div class="ModalHeader">
        <svg viewBox="0 0 18 18" class="Icon IconQuestion"></svg>
        <div class="ModalHeaderTitle">Confirm address</div>
        <svg
          viewBox="0 0 18 18"
          class="Icon IconClose"
          tabindex="0"
          role="button"
          title="Close"
          aria-label="Close"
          aria-expanded="true"
        ></svg>
      </div>
      <div class="ModalDescription">
        We couldn't verify this address. Please check that your information is correct before continuing.
      </div>
      <br />
      <div class="ModalSubheader">
        You entered
      </div>
      <div class="ModalAddress"></div>
      <div
        class="Button ButtonPrimary"
        tabindex="0"
        role="button"
        aria-label="Use the address I provided"
      >
        Use the address I provided
      </div>
    </div>
  </div>
</template>
`);
var _binding3, _themeInternal3, _handleClose2, _modalID2, _modalHeaderTitleID2, _modalAddressID;
var MapboxAddressConfirmationNoFeature = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _binding3, void 0);
    __privateAdd(this, _themeInternal3, {});
    this.update = (autofillValues) => {
      const { ModalAddress } = __privateGet(this, _binding3);
      ModalAddress.innerHTML = "";
      ModalAddress.appendChild(createAddressElement(autofillValues));
    };
    __privateAdd(this, _handleClose2, () => {
      this.dispatchEvent(new MapboxHTMLEvent("result", "cancel"));
    });
    this.reject = () => {
      this.dispatchEvent(new MapboxHTMLEvent("result", "nochange"));
    };
    __privateAdd(this, _modalID2, randomValidID());
    __privateAdd(this, _modalHeaderTitleID2, randomValidID());
    __privateAdd(this, _modalAddressID, randomValidID());
  }
  get template() {
    return TEMPLATE3;
  }
  get templateStyle() {
    return style_default;
  }
  get templateUserStyle() {
    return getThemeCSS(".MapboxAddressConfirmationNoFeature", this.theme);
  }
  get theme() {
    return __privateGet(this, _themeInternal3);
  }
  set theme(theme) {
    __privateSet(this, _themeInternal3, theme);
    if (!__privateGet(this, _binding3) || !theme) {
      return;
    }
    this.updateTemplateUserStyle(getThemeCSS(".MapboxAddressConfirmationNoFeature", theme));
    const { IconQuestion, IconClose } = __privateGet(this, _binding3);
    IconQuestion.innerHTML = getIcon("question", theme);
    IconClose.innerHTML = getIcon("close", theme);
  }
  connectedCallback() {
    super.connectedCallback();
    __privateSet(this, _binding3, bindElements(this, {
      Modal: ".Modal",
      ModalHeaderTitle: ".ModalHeaderTitle",
      IconQuestion: ".IconQuestion",
      IconClose: ".IconClose",
      ModalAddress: ".ModalAddress",
      ButtonReject: ".Button"
    }));
    const { Modal, ModalHeaderTitle, IconClose, ModalAddress, ButtonReject } = __privateGet(this, _binding3);
    Modal.setAttribute("aria-labelledby", __privateGet(this, _modalHeaderTitleID2));
    Modal.setAttribute("aria-describedby", __privateGet(this, _modalAddressID));
    IconClose.setAttribute("aria-controls", __privateGet(this, _modalID2));
    Modal.id = __privateGet(this, _modalID2);
    ModalHeaderTitle.id = __privateGet(this, _modalHeaderTitleID2);
    ModalAddress.id = __privateGet(this, _modalAddressID);
    const buttons = Array.from(this.querySelectorAll('[role="button"]'));
    for (const button of buttons) {
      button.addEventListener("keydown", ariaButtonKeyDown);
    }
    IconClose.addEventListener("click", __privateGet(this, _handleClose2));
    ButtonReject.addEventListener("click", this.reject);
    const theme = this.theme;
    if (theme) {
      const { IconQuestion, IconClose: IconClose2 } = __privateGet(this, _binding3);
      IconQuestion.innerHTML = getIcon("question", theme);
      IconClose2.innerHTML = getIcon("close", theme);
    }
  }
  disconnectedCallback() {
    const { IconClose, ButtonReject } = __privateGet(this, _binding3);
    IconClose.removeEventListener("click", __privateGet(this, _handleClose2));
    ButtonReject.removeEventListener("click", this.reject);
  }
};
_binding3 = new WeakMap();
_themeInternal3 = new WeakMap();
_handleClose2 = new WeakMap();
_modalID2 = new WeakMap();
_modalHeaderTitleID2 = new WeakMap();
_modalAddressID = new WeakMap();
window.MapboxAddressConfirmationNoFeature = MapboxAddressConfirmationNoFeature;
if (!window.customElements.get("mapbox-address-confirmation-no-feature")) {
  customElements.define("mapbox-address-confirmation-no-feature", MapboxAddressConfirmationNoFeature);
}

// src/components/MapboxAddressConfirmation.ts
var import_search_js_core4 = require("@mapbox/search-js-core");
var import_no_scroll = __toESM(require("no-scroll"));
var import_focus_trap = require("focus-trap");
var TEMPLATE4 = createElementFromString(`
<template>
  <div class="MapboxAddressConfirmation" aria-hidden="true">
    <mapbox-address-confirmation-feature class="ContentFeature"></mapbox-address-confirmation-feature>
    <mapbox-address-confirmation-no-feature class="ContentNoFeature"></mapbox-address-confirmation-no-feature>
  </div>
</template>
`);
var _show, _binding4, _focusTrap, _themeInternal4;
var MapboxAddressConfirmation = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _show, false);
    __privateAdd(this, _binding4, void 0);
    __privateAdd(this, _focusTrap, void 0);
    __privateAdd(this, _themeInternal4, {});
  }
  get template() {
    return TEMPLATE4;
  }
  get templateStyle() {
    return style_default;
  }
  get templateUserStyle() {
    return getThemeCSS(".MapboxAddressConfirmation", this.theme);
  }
  get theme() {
    return __privateGet(this, _themeInternal4);
  }
  set theme(theme) {
    __privateSet(this, _themeInternal4, theme);
    if (!__privateGet(this, _binding4) || !theme) {
      return;
    }
    this.updateTemplateUserStyle(getThemeCSS(".MapboxAddressConfirmation", theme));
    const { ContentFeature, ContentNoFeature } = __privateGet(this, _binding4);
    ContentFeature.theme = theme;
    ContentNoFeature.theme = theme;
  }
  connectedCallback() {
    super.connectedCallback();
    __privateSet(this, _binding4, bindElements(this, {
      MapboxAddressConfirmation: ".MapboxAddressConfirmation",
      ContentFeature: ".ContentFeature",
      ContentNoFeature: ".ContentNoFeature"
    }));
    const { MapboxAddressConfirmation: MapboxAddressConfirmation2 } = __privateGet(this, _binding4);
    MapboxAddressConfirmation2.setAttribute("aria-hidden", "true");
    const theme = this.theme;
    if (theme) {
      const { ContentFeature, ContentNoFeature } = __privateGet(this, _binding4);
      ContentFeature.theme = theme;
      ContentNoFeature.theme = theme;
    }
  }
  disconnectedCallback() {
    __privateSet(this, _focusTrap, null);
  }
  hide() {
    var _a;
    __privateSet(this, _show, false);
    if (!__privateGet(this, _binding4)) {
      return;
    }
    const { MapboxAddressConfirmation: MapboxAddressConfirmation2 } = __privateGet(this, _binding4);
    MapboxAddressConfirmation2.setAttribute("aria-hidden", "true");
    (_a = __privateGet(this, _focusTrap)) == null ? void 0 : _a.deactivate();
    import_no_scroll.default.off();
  }
  show(autofillValues, optionsArg, feature) {
    return __async(this, null, function* () {
      var _a;
      if (!__privateGet(this, _binding4)) {
        return { type: "cancel" };
      }
      const { MapboxAddressConfirmation: MapboxAddressConfirmation2, ContentFeature, ContentNoFeature } = __privateGet(this, _binding4);
      const { accessToken, minimap = false, theme } = optionsArg;
      this.theme = theme;
      if (feature) {
        ContentFeature.removeAttribute("aria-hidden");
        ContentNoFeature.setAttribute("aria-hidden", "true");
        ContentFeature.minimap = minimap;
        ContentFeature.accessToken = accessToken;
        ContentFeature.update(feature, autofillValues);
      } else {
        ContentFeature.setAttribute("aria-hidden", "true");
        ContentNoFeature.removeAttribute("aria-hidden");
        ContentNoFeature.update(autofillValues);
      }
      __privateSet(this, _show, true);
      MapboxAddressConfirmation2.removeAttribute("aria-hidden");
      import_no_scroll.default.on();
      const activeContentElement = feature ? ContentFeature : ContentNoFeature;
      __privateSet(this, _focusTrap, (0, import_focus_trap.createFocusTrap)(MapboxAddressConfirmation2, {
        fallbackFocus: activeContentElement,
        escapeDeactivates: () => {
          this.hide();
          return true;
        }
      }));
      (_a = __privateGet(this, _focusTrap)) == null ? void 0 : _a.activate();
      return new Promise((resolve) => {
        const eventHost = activeContentElement;
        const fn = (e) => {
          eventHost.removeEventListener("result", fn);
          const result = e.detail;
          this.hide();
          if (result === "change") {
            resolve({
              type: "change",
              feature
            });
          } else {
            resolve({
              type: result
            });
          }
        };
        eventHost.addEventListener("result", fn);
      });
    });
  }
  tryShow(autofillValues, optionsArg) {
    return __async(this, null, function* () {
      if (!__privateGet(this, _binding4)) {
        return { type: "cancel" };
      }
      const { accessToken, options = {} } = optionsArg;
      const autofill2 = new import_search_js_core4.MapboxAutofill(__spreadValues({
        accessToken
      }, options));
      const searchText = getAutofillSearchText(autofillValues);
      const featureCollection = yield autofill2.retrieve(searchText, {
        sessionToken: config.autofillSessionToken
      });
      const feature = featureCollection.features[0];
      if (feature) {
        const defaultValidation = (feature2) => feature2.properties.match_code.confidence === import_search_js_core4.AutofillMatchCodeConfidence.exact;
        const { skipConfirmModal = defaultValidation } = optionsArg;
        if (skipConfirmModal(feature)) {
          return { type: "nochange" };
        }
      }
      return yield this.show(autofillValues, optionsArg, feature);
    });
  }
};
_show = new WeakMap();
_binding4 = new WeakMap();
_focusTrap = new WeakMap();
_themeInternal4 = new WeakMap();
window.MapboxAddressConfirmation = MapboxAddressConfirmation;
if (!window.customElements.get("mapbox-address-confirmation")) {
  customElements.define("mapbox-address-confirmation", MapboxAddressConfirmation);
}

// src/components/MapboxAddressAutofill.ts
var import_search_js_core5 = require("@mapbox/search-js-core");
var _autofill, _session, _input, _listbox, _handleSuggest2, _handleSuggestError2, _handleRetrieve, _handleObserve, _observer;
var MapboxAddressAutofill = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _autofill, new import_search_js_core5.MapboxAutofill());
    __privateAdd(this, _session, new import_search_js_core5.SearchSession(__privateGet(this, _autofill)));
    __privateAdd(this, _input, void 0);
    __privateAdd(this, _listbox, new MapboxSearchListbox());
    __privateAdd(this, _handleSuggest2, (e) => {
      this.dispatchEvent(e.clone());
    });
    __privateAdd(this, _handleSuggestError2, (e) => {
      this.dispatchEvent(e.clone());
    });
    __privateAdd(this, _handleRetrieve, (e) => {
      this.dispatchEvent(e.clone());
      if (!__privateGet(this, _input)) {
        return;
      }
      const featureCollection = e.detail;
      if (!featureCollection || !featureCollection.features || !featureCollection.features.length) {
        return;
      }
      fillFormWithFeature(featureCollection.features[0], __privateGet(this, _input));
    });
    __privateAdd(this, _handleObserve, () => {
      var _a;
      try {
        const input = (_a = this.querySelector("input")) != null ? _a : null;
        __privateSet(this, _input, input);
        __privateGet(this, _listbox).input = input;
      } catch (e) {
        __privateSet(this, _input, null);
        __privateGet(this, _listbox).input = null;
        console.error(e.message || e);
      }
    });
    __privateAdd(this, _observer, new MutationObserver(__privateGet(this, _handleObserve)));
  }
  get accessToken() {
    return __privateGet(this, _autofill).accessToken;
  }
  set accessToken(newToken) {
    __privateGet(this, _autofill).accessToken = newToken;
  }
  get options() {
    return __privateGet(this, _listbox).options;
  }
  set options(newOptions) {
    __privateGet(this, _listbox).options = newOptions;
  }
  get theme() {
    return __privateGet(this, _listbox).theme;
  }
  set theme(theme) {
    __privateGet(this, _listbox).theme = theme;
  }
  connectedCallback() {
    super.connectedCallback();
    config.autofillSessionEnabled = true;
    __privateGet(this, _listbox).session = __privateGet(this, _session);
    __privateGet(this, _listbox).session.sessionToken = config.autofillSessionToken;
    __privateGet(this, _listbox).addEventListener("suggest", __privateGet(this, _handleSuggest2));
    __privateGet(this, _listbox).addEventListener("suggesterror", __privateGet(this, _handleSuggestError2));
    __privateGet(this, _listbox).addEventListener("retrieve", __privateGet(this, _handleRetrieve));
    document.body.appendChild(__privateGet(this, _listbox));
    __privateGet(this, _observer).observe(this, {
      subtree: true,
      childList: true
    });
    __privateGet(this, _handleObserve).call(this);
  }
  disconnectedCallback() {
    __privateGet(this, _listbox).remove();
    __privateGet(this, _listbox).removeEventListener("suggest", __privateGet(this, _handleSuggest2));
    __privateGet(this, _listbox).removeEventListener("suggesterror", __privateGet(this, _handleSuggestError2));
    __privateGet(this, _listbox).removeEventListener("retrieve", __privateGet(this, _handleRetrieve));
    __privateGet(this, _observer).disconnect();
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "access-token") {
      __privateGet(this, _autofill).accessToken = newValue;
      return;
    }
    if (name === "theme") {
      this.theme = tryParseJSON(newValue);
      return;
    }
    const optionName = name.split("-").join("_");
    if (!newValue) {
      delete __privateGet(this, _listbox).options[optionName];
    }
    __privateGet(this, _listbox).options[optionName] = newValue;
  }
  focus() {
    __privateGet(this, _listbox).focus();
  }
};
_autofill = new WeakMap();
_session = new WeakMap();
_input = new WeakMap();
_listbox = new WeakMap();
_handleSuggest2 = new WeakMap();
_handleSuggestError2 = new WeakMap();
_handleRetrieve = new WeakMap();
_handleObserve = new WeakMap();
_observer = new WeakMap();
MapboxAddressAutofill.observedAttributes = [
  "access-token",
  "theme",
  "css-text",
  "language",
  "country",
  "bbox",
  "limit",
  "proximity"
];
window.MapboxAddressAutofill = MapboxAddressAutofill;
if (!window.customElements.get("mapbox-address-autofill")) {
  customElements.define("mapbox-address-autofill", MapboxAddressAutofill);
}

// src/components/MapboxSearchBox.ts
var import_search_js_core6 = require("@mapbox/search-js-core");
var import_bbox = __toESM(require("@turf/bbox"));
var import_bbox_polygon = __toESM(require("@turf/bbox-polygon"));
var MAX_ZOOM = 9;
var TEMPLATE5 = createElementFromString(`
<template>
  <input class="Input" type="text" />
</template>
`);
var _search, _session2, _map, _input2, _listbox2, _handleSuggest3, _handleSuggestError3, _handleRetrieve2, _handleInput2, _handleMoveEnd;
var MapboxSearchBox = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _search, new import_search_js_core6.MapboxSearch({}));
    __privateAdd(this, _session2, new import_search_js_core6.SearchSession(__privateGet(this, _search)));
    __privateAdd(this, _map, null);
    __privateAdd(this, _input2, void 0);
    __privateAdd(this, _listbox2, new MapboxSearchListbox());
    __privateAdd(this, _handleSuggest3, (e) => {
      this.dispatchEvent(e.clone());
    });
    __privateAdd(this, _handleSuggestError3, (e) => {
      this.dispatchEvent(e.clone());
    });
    __privateAdd(this, _handleRetrieve2, (e) => __async(this, null, function* () {
      var _a;
      this.dispatchEvent(e.clone());
      const featureCollection = e.detail;
      if (!featureCollection || !featureCollection.features.length) {
        return;
      }
      const suggestion = (0, import_search_js_core6.featureToSuggestion)(featureCollection.features[0]);
      __privateGet(this, _input2).value = suggestion.feature_name;
      const map = __privateGet(this, _map);
      if (!map) {
        return;
      }
      const features = featureCollection.features;
      if (features.length === 1) {
        const feature = features[0];
        const placeType = (_a = feature.properties.place_type) == null ? void 0 : _a[0];
        const bounds2 = feature.bbox;
        if (bounds2) {
          map.flyTo(bboxViewport(map, import_search_js_core6.LngLatBounds.convert(bounds2).toFlatArray()));
        } else {
          const center = feature.geometry.coordinates;
          const zoom = getMaxZoom(placeType);
          map.flyTo({
            center,
            zoom,
            speed: FLY_TO_SPEED
          });
        }
        return;
      }
      const geoAccurateFeatures = featureCollection.features.map((feature) => {
        if (feature.bbox) {
          return (0, import_bbox_polygon.default)(import_search_js_core6.LngLatBounds.convert(feature.bbox).toFlatArray());
        }
        return feature;
      });
      const bounds = (0, import_bbox.default)({
        type: "FeatureCollection",
        features: geoAccurateFeatures
      });
      map.flyTo(bboxViewport(map, bounds));
    }));
    __privateAdd(this, _handleInput2, (e) => {
      const event = new MapboxHTMLEvent("input");
      Object.assign(event, __spreadValues({}, e));
      this.dispatchEvent(event);
    });
    __privateAdd(this, _handleMoveEnd, () => {
      const map = __privateGet(this, _map);
      const options = __spreadValues({}, __privateGet(this, _listbox2).options);
      if (map.getZoom() <= MAX_ZOOM) {
        delete options.proximity;
        __privateGet(this, _listbox2).options = options;
        return;
      }
      const center = map.getCenter();
      __privateGet(this, _listbox2).options = __spreadProps(__spreadValues({}, options), {
        proximity: center
      });
    });
  }
  get accessToken() {
    return __privateGet(this, _search).accessToken;
  }
  set accessToken(newToken) {
    __privateGet(this, _search).accessToken = newToken;
  }
  get value() {
    return __privateGet(this, _input2).value;
  }
  set value(newValue) {
    __privateGet(this, _input2).value = newValue;
  }
  get template() {
    return TEMPLATE5;
  }
  get templateStyle() {
    return style_default;
  }
  get templateUserStyle() {
    return getThemeCSS(".Input", __privateGet(this, _listbox2).theme);
  }
  get options() {
    return __privateGet(this, _listbox2).options;
  }
  set options(newOptions) {
    __privateGet(this, _listbox2).options = newOptions;
  }
  get theme() {
    return __privateGet(this, _listbox2).theme;
  }
  set theme(theme) {
    __privateGet(this, _listbox2).theme = theme;
    const input = __privateGet(this, _input2);
    if (!input) {
      return;
    }
    this.updateTemplateUserStyle(getThemeCSS(".Input", theme));
    __privateGet(this, _listbox2).updatePopover();
  }
  connectedCallback() {
    super.connectedCallback();
    const input = this.querySelector(".Input");
    input.addEventListener("input", __privateGet(this, _handleInput2));
    __privateSet(this, _input2, input);
    __privateGet(this, _listbox2).session = __privateGet(this, _session2);
    __privateGet(this, _listbox2).input = input;
    __privateGet(this, _listbox2).addEventListener("suggest", __privateGet(this, _handleSuggest3));
    __privateGet(this, _listbox2).addEventListener("suggesterror", __privateGet(this, _handleSuggestError3));
    __privateGet(this, _listbox2).addEventListener("retrieve", __privateGet(this, _handleRetrieve2));
    document.body.appendChild(__privateGet(this, _listbox2));
  }
  disconnectedCallback() {
    __privateGet(this, _listbox2).remove();
    __privateGet(this, _listbox2).input = null;
    __privateGet(this, _listbox2).removeEventListener("suggest", __privateGet(this, _handleSuggest3));
    __privateGet(this, _listbox2).removeEventListener("suggesterror", __privateGet(this, _handleSuggestError3));
    __privateGet(this, _listbox2).removeEventListener("retrieve", __privateGet(this, _handleRetrieve2));
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "access-token") {
      __privateGet(this, _search).accessToken = newValue;
      return;
    }
    if (name === "theme") {
      this.theme = tryParseJSON(newValue);
      return;
    }
    const optionName = name.split("-").join("_");
    if (!newValue) {
      delete __privateGet(this, _listbox2).options[optionName];
    }
    __privateGet(this, _listbox2).options[optionName] = newValue;
  }
  focus() {
    __privateGet(this, _listbox2).focus();
  }
  bindMap(map) {
    if (__privateGet(this, _map)) {
      __privateGet(this, _map).off("moveend", __privateGet(this, _handleMoveEnd));
    }
    if (map) {
      map.on("moveend", __privateGet(this, _handleMoveEnd));
    }
    __privateSet(this, _map, map);
  }
  unbindMap() {
    this.bindMap(null);
  }
  onAdd(map) {
    this.bindMap(map);
    this.remove();
    const container = document.createElement("div");
    container.className = "mapboxgl-ctrl";
    container.style.width = "300px";
    container.appendChild(this);
    return container;
  }
  onRemove() {
    this.remove();
    this.unbindMap();
  }
  getDefaultPosition() {
    return "top-right";
  }
};
_search = new WeakMap();
_session2 = new WeakMap();
_map = new WeakMap();
_input2 = new WeakMap();
_listbox2 = new WeakMap();
_handleSuggest3 = new WeakMap();
_handleSuggestError3 = new WeakMap();
_handleRetrieve2 = new WeakMap();
_handleInput2 = new WeakMap();
_handleMoveEnd = new WeakMap();
MapboxSearchBox.observedAttributes = [
  "access-token",
  "theme",
  "language",
  "country",
  "bbox",
  "limit",
  "navigation-profile",
  "origin",
  "proximity",
  "eta-type",
  "types"
];
window.MapboxSearchBox = MapboxSearchBox;
if (!window.customElements.get("mapbox-search-box")) {
  customElements.define("mapbox-search-box", MapboxSearchBox);
}

// src/components/MapboxAddressMinimap.ts
var import_search_js_core7 = require("@mapbox/search-js-core");

// src/utils/minimap.ts
var import_sphericalmercator = __toESM(require("@mapbox/sphericalmercator"));
var merc = new import_sphericalmercator.default({ size: 512, antimeridian: true });
var MAX_IMAGE_DIM = 1280;
function getAnchorOffset(marker, anchor) {
  const { width, height } = getElementSize(marker, true);
  switch (anchor) {
    case "center":
      return [0, 0];
    case "top":
      return [0, height / 2];
    case "bottom":
      return [0, -1 * height / 2];
    case "left":
      return [width / 2, 0];
    case "right":
      return [-1 * width / 2, 0];
    case "top-left":
      return [width / 2, height / 2];
    case "top-right":
      return [-1 * width / 2, height / 2];
    case "bottom-left":
      return [width / 2, -1 * height / 2];
    case "bottom-right":
      return [-1 * width / 2, -1 * height / 2];
  }
}
var _anchor, _handleAnchorResize, _markerTransform, _isActive, _originalCoordinate, _onPointerDownMarker, _onPointerUpMarker, _onPointerMoveMarker, _onPointerDownImage, _onPointerUpImage, _onPointerMoveImage, _updatePointerPosition, _updateMarkerTransform;
var MarkerController = class {
  constructor(imageContainer, marker, keepMarkerCentered, zoom, anchor) {
    __privateAdd(this, _anchor, void 0);
    __privateAdd(this, _handleAnchorResize, () => {
      [this.anchorOffsetX, this.anchorOffsetY] = getAnchorOffset(this.markerElement, this.anchor);
      this.markerTransform = {
        anchorX: this.anchorOffsetX,
        anchorY: this.anchorOffsetY
      };
    });
    __privateAdd(this, _markerTransform, {
      anchorX: 0,
      anchorY: 0,
      globalX: 0,
      globalY: 0
    });
    __privateAdd(this, _isActive, false);
    __privateAdd(this, _originalCoordinate, void 0);
    __privateAdd(this, _onPointerDownMarker, (m) => {
      if (!this.isActive)
        return;
      m.preventDefault();
      m.stopPropagation();
      __privateGet(this, _updatePointerPosition).call(this, m);
      window.addEventListener("pointermove", __privateGet(this, _onPointerMoveMarker));
      window.addEventListener("pointerup", __privateGet(this, _onPointerUpMarker));
    });
    __privateAdd(this, _onPointerUpMarker, () => {
      window.removeEventListener("pointermove", __privateGet(this, _onPointerMoveMarker));
      window.removeEventListener("pointerup", __privateGet(this, _onPointerUpMarker));
    });
    __privateAdd(this, _onPointerMoveMarker, (m) => {
      m.preventDefault();
      m.stopPropagation();
      const diffX = this.curPointerXPos - m.pageX;
      const diffY = this.curPointerYPos - m.pageY;
      this.markerDeltaX += diffX;
      this.markerDeltaY -= diffY;
      this.markerDeltaX = Math.max(Math.min(this.imgWidth / 2, this.markerDeltaX), this.imgWidth / 2 * -1);
      this.markerDeltaY = Math.max(Math.min(this.imgHeight / 2, this.markerDeltaY), this.imgHeight / 2 * -1);
      const imageOffsetX = this.imgCenterPx[0] - this.imgCenterAdjustedPx[0];
      const imageOffsetY = this.imgCenterPx[1] - this.imgCenterAdjustedPx[1];
      const deltaX = this.markerDeltaX - imageOffsetX;
      const deltaY = this.markerDeltaY + imageOffsetY;
      this.markerTransform = { globalX: deltaX, globalY: deltaY };
      __privateGet(this, _updatePointerPosition).call(this, m);
    });
    __privateAdd(this, _onPointerDownImage, (m) => {
      if (!this.isActive)
        return;
      m.preventDefault();
      m.stopPropagation();
      __privateGet(this, _updatePointerPosition).call(this, m);
      window.addEventListener("pointermove", __privateGet(this, _onPointerMoveImage));
      window.addEventListener("pointerup", __privateGet(this, _onPointerUpImage));
    });
    __privateAdd(this, _onPointerUpImage, () => {
      window.removeEventListener("pointermove", __privateGet(this, _onPointerMoveImage));
      window.removeEventListener("pointerup", __privateGet(this, _onPointerUpImage));
    });
    __privateAdd(this, _onPointerMoveImage, (m) => {
      m.preventDefault();
      let top = Math.round(this.imgContainerElement.scrollTop + (this.curPointerYPos - m.pageY));
      top = Math.max(Math.min(this.imgHeight - this.imgContainerElement.clientHeight, top), 0);
      let left = Math.round(this.imgContainerElement.scrollLeft + (this.curPointerXPos - m.pageX));
      left = Math.max(Math.min(this.imgWidth - this.imgContainerElement.clientWidth, left), 0);
      this.imgContainerElement.scrollTop = top;
      this.imgContainerElement.scrollLeft = left;
      const diffX = Math.round(left - (this.imgWidth - this.imgContainerElement.clientWidth) / 2);
      const diffY = Math.round((this.imgHeight - this.imgContainerElement.clientHeight) / 2 - top);
      this.imgCenterAdjustedPx = [
        this.imgCenterPx[0] + diffX,
        this.imgCenterPx[1] - diffY
      ];
      if (!this.keepMarkerCentered) {
        const deltaX = this.markerDeltaX + diffX;
        const deltaY = this.markerDeltaY + diffY;
        this.markerTransform = { globalX: deltaX, globalY: deltaY };
      }
      __privateGet(this, _updatePointerPosition).call(this, m);
    });
    __privateAdd(this, _updatePointerPosition, (m) => {
      this.curPointerXPos = m.pageX;
      this.curPointerYPos = m.pageY;
    });
    __privateAdd(this, _updateMarkerTransform, () => {
      const { anchorX, anchorY, globalX, globalY } = __privateGet(this, _markerTransform);
      const transformX = anchorX - globalX;
      const transformY = anchorY + globalY;
      this.markerElement.style.transform = `translate(calc(-50% + ${transformX}px), calc(-50% + ${transformY}px))`;
    });
    this.reCenter = () => {
      const top = (this.imgHeight - this.imgContainerElement.clientHeight) / 2;
      const left = (this.imgWidth - this.imgContainerElement.clientWidth) / 2;
      this.imgContainerElement.scrollTop = top;
      this.imgContainerElement.scrollLeft = left;
      this.imgCenterAdjustedPx = this.imgCenterPx;
      this.markerDeltaX = this.markerDeltaY = 0;
      this.markerTransform = { globalX: 0, globalY: 0 };
    };
    this.markerElement = marker;
    this.imgContainerElement = imageContainer;
    this.keepMarkerCentered = keepMarkerCentered;
    this.zoom = zoom;
    this.anchor = anchor;
    this.curPointerXPos = 0;
    this.curPointerYPos = 0;
    this.markerDeltaX = 0;
    this.markerDeltaY = 0;
    this.imgContainerElement.addEventListener("pointerdown", __privateGet(this, _onPointerDownImage));
    if (!this.keepMarkerCentered) {
      this.markerElement.addEventListener("pointerdown", __privateGet(this, _onPointerDownMarker));
    }
    const resizeObserver = new ResizeObserver(__privateGet(this, _handleAnchorResize));
    resizeObserver.observe(this.markerElement);
  }
  get anchor() {
    return __privateGet(this, _anchor);
  }
  set anchor(newAnchor) {
    __privateSet(this, _anchor, newAnchor);
    [this.anchorOffsetX, this.anchorOffsetY] = getAnchorOffset(this.markerElement, newAnchor);
    this.markerTransform = {
      anchorX: this.anchorOffsetX,
      anchorY: this.anchorOffsetY
    };
  }
  get markerTransform() {
    return __privateGet(this, _markerTransform);
  }
  set markerTransform(val) {
    __privateSet(this, _markerTransform, __spreadValues(__spreadValues({}, __privateGet(this, _markerTransform)), val));
    __privateGet(this, _updateMarkerTransform).call(this);
  }
  get isActive() {
    return __privateGet(this, _isActive);
  }
  set isActive(val) {
    this.imgContainerElement.style.touchAction = val ? "none" : "";
    __privateSet(this, _isActive, val);
  }
  get imgHeight() {
    return Math.min(this.imgContainerElement.clientHeight * 2, MAX_IMAGE_DIM);
  }
  get imgWidth() {
    return Math.min(this.imgContainerElement.clientWidth * 2, MAX_IMAGE_DIM);
  }
  get coordinate() {
    const adjustedPx = this.keepMarkerCentered ? this.imgCenterAdjustedPx : [
      this.imgCenterPx[0] - this.markerDeltaX,
      this.imgCenterPx[1] + this.markerDeltaY
    ];
    if (deepEquals(adjustedPx, this.imgCenterPx)) {
      return __privateGet(this, _originalCoordinate);
    } else {
      const lngLat = merc.ll(adjustedPx, this.zoom);
      return [round(lngLat[0], 6), round(lngLat[1], 6)];
    }
  }
  set coordinate(lngLat) {
    __privateSet(this, _originalCoordinate, lngLat);
    this.imgCenterPx = this.imgCenterAdjustedPx = merc.px(lngLat, this.zoom);
  }
};
_anchor = new WeakMap();
_handleAnchorResize = new WeakMap();
_markerTransform = new WeakMap();
_isActive = new WeakMap();
_originalCoordinate = new WeakMap();
_onPointerDownMarker = new WeakMap();
_onPointerUpMarker = new WeakMap();
_onPointerMoveMarker = new WeakMap();
_onPointerDownImage = new WeakMap();
_onPointerUpImage = new WeakMap();
_onPointerMoveImage = new WeakMap();
_updatePointerPosition = new WeakMap();
_updateMarkerTransform = new WeakMap();

// src/icons/mapboxgl-ctrl-logo.svg
var mapboxgl_ctrl_logo_default = '<svg width="88" height="23" viewBox="0 0 88 23" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill-rule="evenodd">\n    <defs>\n        <path id="logo" d="M11.5 2.25c5.105 0 9.25 4.145 9.25 9.25s-4.145 9.25-9.25 9.25-9.25-4.145-9.25-9.25 4.145-9.25 9.25-9.25zM6.997 15.983c-.051-.338-.828-5.802 2.233-8.873a4.395 4.395 0 013.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39 0 1.18-.449 2.301-1.28 3.13C12.72 16.93 7 16 7 16l-.003-.017zM15.3 10.5l-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z" />\n        <path id="text" d="M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19c-1.04 0-2.03-.43-2.74-1.18v3.77c0 .13-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01c.01 0 .01 0 .01-.01.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V15c-.7.76-1.69 1.19-2.73 1.19-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.375-.19a4.24 4.24 0 00-4.16 3.29c-.13.59-.13 1.19 0 1.77a4.233 4.233 0 004.17 3.3c2.35 0 4.26-1.87 4.26-4.19 0-2.32-1.9-4.17-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18 1.88 0 3.45 1.4 3.84 3.28.13.59.13 1.2 0 1.8-.39 1.88-1.96 3.29-3.84 3.29-1.03 0-2.02-.43-2.73-1.18v.77c0 .12-.1.23-.23.23h-1.4c-.13 0-.23-.1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4c-.13 0-.23-.11-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55.45-.95 1.4-1.55 2.44-1.56 1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41c-.13 0-.23-.11-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.615 0h-1.61c-.04 0-.08-.01-.12-.03-.09-.06-.13-.19-.06-.28l2.43-3.71-2.39-3.65a.213.213 0 01-.03-.12c0-.12.09-.21.21-.21h1.61c.13 0 .24.06.3.17l1.41 2.37 1.4-2.37a.34.34 0 01.3-.17h1.6c.04 0 .08.01.12.03.09.06.13.19.06.28l-2.37 3.65 2.43 3.7c0 .05.01.09.01.13 0 .12-.09.21-.21.21h-1.61c-.13 0-.24-.06-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 01-.3.17zm-7.12-1.49c-1.33 0-2.42-1.12-2.42-2.51 0-1.39 1.08-2.52 2.42-2.52 1.33 0 2.42 1.12 2.42 2.51 0 1.39-1.08 2.51-2.42 2.52zm-19.865 0c-1.32 0-2.39-1.11-2.42-2.48v-.07c.02-1.38 1.09-2.49 2.4-2.49 1.32 0 2.41 1.12 2.41 2.51 0 1.39-1.07 2.52-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51c0-1.39 1.08-2.52 2.4-2.52 1.33 0 2.39 1.11 2.41 2.48l.02.08zm18.12 2.47c-1.32 0-2.39-1.11-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51c0 1.39-1.09 2.51-2.42 2.51z" />\n    </defs>\n    <mask id="clip">\n        <rect x="0" y="0" width="100%" height="100%" fill="white" />\n        <use xlink:href="#logo" />\n        <use xlink:href="#text" />\n    </mask>\n\n    <g id="outline" opacity="0.3" stroke="#000" stroke-width="3">\n        <circle mask="url(#clip)" cx="11.5" cy="11.5" r="9.25" />\n        <use xlink:href="#text" mask="url(#clip)" />\n    </g>\n    <g id="fill" opacity="0.9" fill="#fff" >\n        <use xlink:href="#logo" />\n        <use xlink:href="#text" />\n    </g>\n</svg>\n';

// src/components/MapboxAddressMinimap.ts
var ZOOM = 16;
var TEMPLATE6 = createElementFromString(`
<template>
  <div class="MapboxAddressMinimap" aria-hidden="true">
    <div class="MinimapImageContainer">
      <img class="MinimapImage" draggable="false"></img>
      <div class="MinimapInnerFrame">
        <div class="MinimapMarker"></div>
        <div class="MinimapAttribution">
          <div class="MinimapAttributionLogo">
            <a target="_blank" rel="noopener nofollow" href="https://www.mapbox.com/" aria-label="Mapbox logo">
              ${mapboxgl_ctrl_logo_default}
            </a>
          </div>
          <div class="MinimapAttributionText">
            <a target="_blank" href='https://www.mapbox.com/about/maps/'>\xA9 Mapbox</a><a target="_blank" href='http://www.openstreetmap.org/copyright'>\xA9 OpenStreetMap</a>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
`);
var STYLE_TOGGLE_TEMPLATE = createElementFromString(`
<template>
  <button type="button" class="MinimapStyleToggle"></button>
</template>
`);
var FOOTER_TEMPLATE = createElementFromString(`
<template>
  <div class="MinimapFooter">Adjust the marker on the map if it doesn't precisely match your location. This helps your delivery reach you faster.</div>
</template>
`);
var EDIT_BUTTONS_TEMPLATE = createElementFromString(`
<template>
  <div class="MinimapEditButtons">
    <div class="Button ButtonPrimary MinimapButtonAdjust">Adjust pin</div>
    <div class="Button ButtonPrimary MinimapButtonSave" aria-hidden="true">Save</div>
    <div class="Button MinimapButtonCancel" aria-hidden="true">Cancel</div>
  </div>
</template>
`);
var _canAdjustMarkerInternal, _isAdjustMarkerEditing, _imageLoaded, _feature2, _url, _width, _height, _binding5, _markerController, _accessToken, _themeInternal5, _satelliteToggleInternal, _mapStyleMode, _defaultMapStyle, _container, _toggleMarkerEditing, _handleStartMarkerEditing, _handleSaveMarkerEditing, _handleCancelMarkerEditing, _handleToggleMapStyle, _handleImageLoad, _handleImageError, _getImageUrl, _updateImageSrc, _getToggleBackgroundImageUrl, _setSize, _addMarkerEditControls, _removeMarkerEditControls, _addSatelliteToggle, _removeSatelliteToggle;
var MapboxAddressMinimap = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _canAdjustMarkerInternal, false);
    this.keepMarkerCentered = false;
    this.markerAnchor = "bottom";
    __privateAdd(this, _isAdjustMarkerEditing, false);
    __privateAdd(this, _imageLoaded, false);
    __privateAdd(this, _feature2, void 0);
    __privateAdd(this, _url, "");
    __privateAdd(this, _width, void 0);
    __privateAdd(this, _height, void 0);
    __privateAdd(this, _binding5, void 0);
    __privateAdd(this, _markerController, void 0);
    __privateAdd(this, _accessToken, void 0);
    __privateAdd(this, _themeInternal5, {});
    __privateAdd(this, _satelliteToggleInternal, false);
    __privateAdd(this, _mapStyleMode, "default");
    __privateAdd(this, _defaultMapStyle, ["mapbox", "streets-v11"]);
    __privateAdd(this, _container, void 0);
    __privateAdd(this, _toggleMarkerEditing, () => {
      const { ImageContainer, ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding5);
      if (__privateGet(this, _isAdjustMarkerEditing)) {
        ImageContainer.classList.add(`${this.dataset.seed}--draggable`);
        __privateGet(this, _markerController).isActive = true;
        ButtonAdjust.setAttribute("aria-hidden", "true");
        ButtonSave.removeAttribute("aria-hidden");
        ButtonCancel.removeAttribute("aria-hidden");
      } else {
        ImageContainer.classList.remove(`${this.dataset.seed}--draggable`);
        __privateGet(this, _markerController).isActive = false;
        ButtonAdjust.removeAttribute("aria-hidden");
        ButtonSave.setAttribute("aria-hidden", "true");
        ButtonCancel.setAttribute("aria-hidden", "true");
      }
    });
    __privateAdd(this, _handleStartMarkerEditing, () => {
      __privateSet(this, _isAdjustMarkerEditing, true);
      __privateGet(this, _toggleMarkerEditing).call(this);
    });
    __privateAdd(this, _handleSaveMarkerEditing, () => {
      if (this.feature.properties.full_address && !deepEquals(this.feature.geometry.coordinates, __privateGet(this, _markerController).coordinate)) {
        const [lng, lat] = __privateGet(this, _markerController).coordinate;
        sendFeedback(this.accessToken, {
          originalCoordinate: this.feature.geometry.coordinates,
          originalAddress: this.feature.properties.full_address,
          changes: {
            location: { longitude: lng, latitude: lat }
          }
        });
      }
      if (this.onSaveMarkerLocation) {
        this.onSaveMarkerLocation(__privateGet(this, _markerController).coordinate);
      }
      __privateSet(this, _isAdjustMarkerEditing, false);
      __privateGet(this, _toggleMarkerEditing).call(this);
    });
    __privateAdd(this, _handleCancelMarkerEditing, () => {
      __privateGet(this, _markerController).reCenter();
      __privateSet(this, _isAdjustMarkerEditing, false);
      __privateGet(this, _toggleMarkerEditing).call(this);
    });
    __privateAdd(this, _handleToggleMapStyle, () => {
      this.mapStyleMode = this.mapStyleMode === "default" ? "satellite" : "default";
    });
    __privateAdd(this, _handleImageLoad, () => {
      if (!__privateGet(this, _imageLoaded)) {
        __privateGet(this, _markerController).reCenter();
      }
      __privateSet(this, _imageLoaded, true);
    });
    __privateAdd(this, _handleImageError, () => {
      __privateSet(this, _imageLoaded, false);
    });
    __privateAdd(this, _getImageUrl, (lngLatLike) => {
      if (__privateGet(this, _width) === 0 || __privateGet(this, _height) === 0)
        return "";
      const [username, styleId] = this.defaultMapStyle;
      const defaultBaseUrl = getStaticBaseUrl(username, styleId);
      const baseUrl = this.mapStyleMode === "default" ? defaultBaseUrl : STATIC_BASE_URL_SATELLITE;
      const skuToken = AUTOFILL_SKU_TOKEN_PREFIX + config.autofillSessionToken.toString();
      let imgUrl = baseUrl + import_search_js_core7.LngLat.convert(lngLatLike).toArray().join(",") + "," + ZOOM + ",0/" + Math.min(__privateGet(this, _width) * 2, MAX_IMAGE_DIM) + "x" + Math.min(__privateGet(this, _height) * 2, MAX_IMAGE_DIM) + "?access_token=" + this.accessToken + "&attribution=false&logo=false";
      if (config.autofillSessionEnabled) {
        imgUrl += `&sku=${skuToken}`;
      }
      return imgUrl;
    });
    __privateAdd(this, _updateImageSrc, () => {
      if (__privateGet(this, _feature2)) {
        const lngLat = __privateGet(this, _feature2).geometry.coordinates;
        __privateSet(this, _url, __privateGet(this, _getImageUrl).call(this, lngLat));
        const { Image } = __privateGet(this, _binding5);
        Image.src = __privateGet(this, _url);
      }
    });
    __privateAdd(this, _getToggleBackgroundImageUrl, (styleMode) => {
      return `url("${getImage(styleMode === "default" ? "styleToggleDefault" : "styleToggleSatellite", this.theme)}")`;
    });
    __privateAdd(this, _setSize, () => {
      const { MapboxAddressMinimap: MapboxAddressMinimap2, ImageContainer } = __privateGet(this, _binding5);
      const { width, height } = getElementSize(this.container);
      __privateSet(this, _width, Math.min(width, MAX_IMAGE_DIM));
      __privateSet(this, _height, Math.min(height, MAX_IMAGE_DIM));
      MapboxAddressMinimap2.style.setProperty("width", `${__privateGet(this, _width)}px`);
      ImageContainer.style.setProperty("height", `${__privateGet(this, _height)}px`);
      ImageContainer.style.setProperty("width", `${__privateGet(this, _width)}px`);
      __privateGet(this, _updateImageSrc).call(this);
    });
    __privateAdd(this, _addMarkerEditControls, () => {
      const existingFooter = this.querySelector(".MinimapFooter");
      if (existingFooter)
        return;
      const footerElement = this.prepareTemplate(FOOTER_TEMPLATE);
      const minimapElement = this.querySelector(".MapboxAddressMinimap");
      if (!minimapElement)
        return;
      minimapElement.appendChild(footerElement);
      const existingEditBtns = this.querySelector(".MinimapEditButtons");
      if (existingEditBtns)
        return;
      const editButtonsElement = this.prepareTemplate(EDIT_BUTTONS_TEMPLATE);
      const innerFrame = this.querySelector(".MinimapInnerFrame");
      innerFrame.appendChild(editButtonsElement);
      __privateSet(this, _binding5, __spreadProps(__spreadValues({}, __privateGet(this, _binding5)), {
        EditButtons: this.querySelector(".MinimapEditButtons"),
        ButtonAdjust: this.querySelector(".MinimapButtonAdjust"),
        ButtonSave: this.querySelector(".MinimapButtonSave"),
        ButtonCancel: this.querySelector(".MinimapButtonCancel")
      }));
      const { ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding5);
      ButtonAdjust.addEventListener("click", __privateGet(this, _handleStartMarkerEditing));
      ButtonSave.addEventListener("click", __privateGet(this, _handleSaveMarkerEditing));
      ButtonCancel.addEventListener("click", __privateGet(this, _handleCancelMarkerEditing));
    });
    __privateAdd(this, _removeMarkerEditControls, () => {
      if (!__privateGet(this, _binding5))
        return;
      const { EditButtons, ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding5);
      const existingFooter = this.querySelector(".MinimapFooter");
      existingFooter == null ? void 0 : existingFooter.remove();
      EditButtons == null ? void 0 : EditButtons.remove();
      if (ButtonAdjust) {
        ButtonAdjust.remove();
        ButtonAdjust.removeEventListener("click", __privateGet(this, _handleStartMarkerEditing));
      }
      if (ButtonSave) {
        ButtonSave.remove();
        ButtonSave.removeEventListener("click", __privateGet(this, _handleSaveMarkerEditing));
      }
      if (ButtonCancel) {
        ButtonCancel.remove();
        ButtonCancel.removeEventListener("click", __privateGet(this, _handleCancelMarkerEditing));
      }
      delete __privateGet(this, _binding5).EditButtons;
      delete __privateGet(this, _binding5).ButtonAdjust;
      delete __privateGet(this, _binding5).ButtonSave;
      delete __privateGet(this, _binding5).ButtonCancel;
    });
    __privateAdd(this, _addSatelliteToggle, () => {
      const existingToggle = this.querySelector(".MinimapStyleToggle");
      if (existingToggle)
        return;
      const toggleElement = this.prepareTemplate(STYLE_TOGGLE_TEMPLATE);
      const innerFrame = this.querySelector(".MinimapInnerFrame");
      if (!innerFrame)
        return;
      innerFrame.appendChild(toggleElement);
      __privateGet(this, _binding5).MapStyleToggle = toggleElement;
      toggleElement.addEventListener("click", __privateGet(this, _handleToggleMapStyle));
      toggleElement.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, this.mapStyleMode === "default" ? "satellite" : "default");
      toggleElement.setAttribute("title", `Switch to ${this.mapStyleMode === "default" ? "Satellite" : "Default"}`);
    });
    __privateAdd(this, _removeSatelliteToggle, () => {
      if (!__privateGet(this, _binding5))
        return;
      const { MapStyleToggle } = __privateGet(this, _binding5);
      if (!MapStyleToggle)
        return;
      MapStyleToggle.remove();
      MapStyleToggle.removeEventListener("click", __privateGet(this, _handleToggleMapStyle));
      delete __privateGet(this, _binding5).MapStyleToggle;
    });
  }
  get canAdjustMarker() {
    return __privateGet(this, _canAdjustMarkerInternal);
  }
  set canAdjustMarker(val) {
    __privateSet(this, _canAdjustMarkerInternal, val);
    val ? __privateGet(this, _addMarkerEditControls).call(this) : __privateGet(this, _removeMarkerEditControls).call(this);
  }
  get accessToken() {
    return __privateGet(this, _accessToken) || config.accessToken;
  }
  set accessToken(newToken) {
    __privateSet(this, _accessToken, newToken);
  }
  get feature() {
    return __privateGet(this, _feature2);
  }
  set feature(feature) {
    __privateSet(this, _feature2, feature);
    if (!feature) {
      this.hide();
    } else {
      this.show();
    }
  }
  get template() {
    return TEMPLATE6;
  }
  get templateStyle() {
    return style_default;
  }
  get templateUserStyle() {
    return getThemeCSS(".MapboxAddressMinimap", this.theme);
  }
  get satelliteToggle() {
    return __privateGet(this, _satelliteToggleInternal);
  }
  set satelliteToggle(val) {
    __privateSet(this, _satelliteToggleInternal, val);
    val ? __privateGet(this, _addSatelliteToggle).call(this) : __privateGet(this, _removeSatelliteToggle).call(this);
  }
  get theme() {
    return __privateGet(this, _themeInternal5);
  }
  set theme(theme) {
    __privateSet(this, _themeInternal5, theme);
    if (!__privateGet(this, _binding5) || !theme) {
      return;
    }
    this.updateTemplateUserStyle(getThemeCSS(".MapboxAddressMinimap", theme));
    const { Marker, MapStyleToggle } = __privateGet(this, _binding5);
    Marker.innerHTML = getIcon("marker", theme);
    if (MapStyleToggle) {
      MapStyleToggle.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, this.mapStyleMode === "default" ? "satellite" : "default");
    }
  }
  get mapStyleMode() {
    return __privateGet(this, _mapStyleMode);
  }
  set mapStyleMode(styleMode) {
    const prevStyleMode = __privateGet(this, _mapStyleMode);
    __privateSet(this, _mapStyleMode, styleMode);
    if (!__privateGet(this, _binding5)) {
      return;
    }
    const { MapStyleToggle } = __privateGet(this, _binding5);
    if (!MapStyleToggle) {
      return;
    }
    MapStyleToggle.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, prevStyleMode);
    MapStyleToggle.setAttribute("title", `Switch to ${prevStyleMode === "satellite" ? "Satellite" : "Default"}`);
    __privateGet(this, _updateImageSrc).call(this);
  }
  get defaultMapStyle() {
    return __privateGet(this, _defaultMapStyle);
  }
  set defaultMapStyle(style) {
    __privateSet(this, _defaultMapStyle, style);
    __privateGet(this, _updateImageSrc).call(this);
  }
  get container() {
    return __privateGet(this, _container);
  }
  set container(newContainer) {
    if (newContainer) {
      newContainer.style.position = "relative";
      __privateSet(this, _container, newContainer);
    }
  }
  show() {
    if (!__privateGet(this, _feature2)) {
      return;
    }
    const lngLat = __privateGet(this, _feature2).geometry.coordinates;
    __privateGet(this, _markerController).coordinate = lngLat;
    __privateSet(this, _url, __privateGet(this, _getImageUrl).call(this, lngLat));
    const { MapboxAddressMinimap: MapboxAddressMinimap2, Image } = __privateGet(this, _binding5);
    Image.src = __privateGet(this, _url);
    MapboxAddressMinimap2.removeAttribute("aria-hidden");
  }
  hide() {
    const { MapboxAddressMinimap: MapboxAddressMinimap2 } = __privateGet(this, _binding5);
    MapboxAddressMinimap2.setAttribute("aria-hidden", "true");
  }
  connectedCallback() {
    super.connectedCallback();
    __privateSet(this, _binding5, bindElements(this, {
      MapboxAddressMinimap: ".MapboxAddressMinimap",
      ImageContainer: ".MinimapImageContainer",
      Image: ".MinimapImage",
      Marker: ".MinimapMarker",
      MapStyleToggle: ".MinimapStyleToggle",
      EditButtons: ".MinimapEditButtons",
      ButtonAdjust: ".MinimapButtonAdjust",
      ButtonSave: ".MinimapButtonSave",
      ButtonCancel: ".MinimapButtonCancel"
    }));
    this.mapStyleMode = __privateGet(this, _mapStyleMode);
    this.theme = __spreadValues({}, this.theme);
    if (this.canAdjustMarker) {
      __privateGet(this, _addMarkerEditControls).call(this);
    }
    if (this.satelliteToggle) {
      __privateGet(this, _addSatelliteToggle).call(this);
    }
    this.container = this.parentElement;
    const resizeObserver = new ResizeObserver(__privateGet(this, _setSize));
    resizeObserver.observe(this.container);
    __privateGet(this, _setSize).call(this);
    const { MapboxAddressMinimap: MapboxAddressMinimap2, ImageContainer, Image, Marker } = __privateGet(this, _binding5);
    __privateSet(this, _markerController, new MarkerController(ImageContainer, Marker, this.keepMarkerCentered, ZOOM, this.markerAnchor));
    __privateGet(this, _markerController).reCenter();
    Image.onload = __privateGet(this, _handleImageLoad);
    Image.onerror = __privateGet(this, _handleImageError);
    Image.src = __privateGet(this, _url);
    if (__privateGet(this, _feature2))
      MapboxAddressMinimap2.removeAttribute("aria-hidden");
    else
      MapboxAddressMinimap2.setAttribute("aria-hidden", "true");
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "access-token") {
      this.accessToken = newValue;
    } else if (name === "can-adjust-marker") {
      this.canAdjustMarker = newValue === "true";
    } else if (name === "keep-marker-centered") {
      this.keepMarkerCentered = newValue === "true";
    } else if (name === "marker-anchor") {
      const newAnchor = newValue;
      this.markerAnchor = newAnchor;
      __privateGet(this, _markerController) && (__privateGet(this, _markerController).anchor = newAnchor);
    } else if (name === "satellite-toggle") {
      this.satelliteToggle = newValue === "true";
    }
  }
};
_canAdjustMarkerInternal = new WeakMap();
_isAdjustMarkerEditing = new WeakMap();
_imageLoaded = new WeakMap();
_feature2 = new WeakMap();
_url = new WeakMap();
_width = new WeakMap();
_height = new WeakMap();
_binding5 = new WeakMap();
_markerController = new WeakMap();
_accessToken = new WeakMap();
_themeInternal5 = new WeakMap();
_satelliteToggleInternal = new WeakMap();
_mapStyleMode = new WeakMap();
_defaultMapStyle = new WeakMap();
_container = new WeakMap();
_toggleMarkerEditing = new WeakMap();
_handleStartMarkerEditing = new WeakMap();
_handleSaveMarkerEditing = new WeakMap();
_handleCancelMarkerEditing = new WeakMap();
_handleToggleMapStyle = new WeakMap();
_handleImageLoad = new WeakMap();
_handleImageError = new WeakMap();
_getImageUrl = new WeakMap();
_updateImageSrc = new WeakMap();
_getToggleBackgroundImageUrl = new WeakMap();
_setSize = new WeakMap();
_addMarkerEditControls = new WeakMap();
_removeMarkerEditControls = new WeakMap();
_addSatelliteToggle = new WeakMap();
_removeSatelliteToggle = new WeakMap();
MapboxAddressMinimap.observedAttributes = [
  "access-token",
  "can-adjust-marker",
  "keep-marker-centered",
  "marker-anchor",
  "satellite-toggle"
];
window.MapboxAddressMinimap = MapboxAddressMinimap;
if (!window.customElements.get("mapbox-address-minimap")) {
  customElements.define("mapbox-address-minimap", MapboxAddressMinimap);
}

// src/autofill.ts
var import_search_js_core8 = require("@mapbox/search-js-core");
var _input3, _collection, _handleSuggest4, _handleSuggestError4, _handleRetrieve3;
var AutofillInstance = class {
  constructor(collection, input, autofillRef) {
    __privateAdd(this, _input3, void 0);
    __privateAdd(this, _collection, void 0);
    this.listbox = new MapboxSearchListbox();
    __privateAdd(this, _handleSuggest4, (e) => {
      __privateGet(this, _collection).fire("suggest", e.clone(__privateGet(this, _input3)));
    });
    __privateAdd(this, _handleSuggestError4, (e) => {
      __privateGet(this, _collection).fire("suggesterror", e.clone(__privateGet(this, _input3)));
    });
    __privateAdd(this, _handleRetrieve3, (e) => {
      __privateGet(this, _collection).fire("retrieve", e.clone(__privateGet(this, _input3)));
      if (!__privateGet(this, _input3)) {
        return;
      }
      const featureCollection = e.detail;
      if (!featureCollection || !featureCollection.features || !featureCollection.features.length) {
        return;
      }
      fillFormWithFeature(featureCollection.features[0], __privateGet(this, _input3));
    });
    __privateSet(this, _input3, input);
    __privateSet(this, _collection, collection);
    this.listbox.input = __privateGet(this, _input3);
    this.listbox.session = new import_search_js_core8.SearchSession(autofillRef);
    this.listbox.session.sessionToken = config.autofillSessionToken;
    this.listbox.addEventListener("suggest", __privateGet(this, _handleSuggest4));
    this.listbox.addEventListener("suggesterror", __privateGet(this, _handleSuggestError4));
    this.listbox.addEventListener("retrieve", __privateGet(this, _handleRetrieve3));
    document.body.appendChild(this.listbox);
  }
  remove() {
    this.listbox.remove();
    this.listbox.removeEventListener("suggest", __privateGet(this, _handleSuggest4));
    this.listbox.removeEventListener("suggesterror", __privateGet(this, _handleSuggestError4));
    this.listbox.removeEventListener("retrieve", __privateGet(this, _handleRetrieve3));
  }
};
_input3 = new WeakMap();
_collection = new WeakMap();
_handleSuggest4 = new WeakMap();
_handleSuggestError4 = new WeakMap();
_handleRetrieve3 = new WeakMap();
var _currentInputs, _autofill2, _options, _theme, _handleObserve2, _observer2;
var AutofillCollection = class extends import_search_js_core8.Evented {
  constructor({ accessToken, options, theme }) {
    super();
    this.instances = [];
    __privateAdd(this, _currentInputs, void 0);
    __privateAdd(this, _autofill2, new import_search_js_core8.MapboxAutofill());
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _theme, void 0);
    __privateAdd(this, _handleObserve2, () => {
      if (!deepEquals(findAddressInputs(), __privateGet(this, _currentInputs))) {
        this.update();
      }
    });
    __privateAdd(this, _observer2, new MutationObserver(__privateGet(this, _handleObserve2)));
    config.autofillSessionEnabled = true;
    this.accessToken = accessToken || config.accessToken;
    options && (this.options = options);
    theme && (this.theme = theme);
    this.update();
  }
  get accessToken() {
    return __privateGet(this, _autofill2).accessToken;
  }
  set accessToken(newToken) {
    __privateGet(this, _autofill2).accessToken = newToken;
  }
  get options() {
    return __privateGet(this, _options);
  }
  set options(newOptions) {
    __privateSet(this, _options, __spreadValues(__spreadValues({}, __privateGet(this, _options)), newOptions));
    this.instances.forEach((instance) => {
      instance.listbox.options = __spreadValues(__spreadValues({}, instance.listbox.options), newOptions);
    });
  }
  get theme() {
    return __privateGet(this, _theme);
  }
  set theme(newTheme) {
    __privateSet(this, _theme, newTheme);
    this.instances.forEach((instance) => {
      instance.listbox.theme = newTheme;
    });
  }
  update() {
    this.instances.forEach((instance) => {
      instance.remove();
    });
    __privateSet(this, _currentInputs, findAddressInputs());
    this.instances = [];
    __privateGet(this, _currentInputs).forEach((input) => {
      const autofillInstance = new AutofillInstance(this, input, __privateGet(this, _autofill2));
      autofillInstance.listbox.options = this.options;
      autofillInstance.listbox.theme = this.theme;
      this.instances.push(autofillInstance);
    });
  }
  observe() {
    __privateGet(this, _observer2).observe(document, {
      subtree: true,
      childList: true
    });
    __privateGet(this, _handleObserve2).call(this);
  }
  unobserve() {
    __privateGet(this, _observer2).disconnect();
  }
};
_currentInputs = new WeakMap();
_autofill2 = new WeakMap();
_options = new WeakMap();
_theme = new WeakMap();
_handleObserve2 = new WeakMap();
_observer2 = new WeakMap();
function autofill(optionsArg) {
  const { accessToken, options } = optionsArg;
  return new AutofillCollection({
    accessToken,
    options
  });
}

// src/confirmAddress.ts
var import_search_js_core9 = require("@mapbox/search-js-core");
var confirmation = new MapboxAddressConfirmation();
function confirmAddress(_0) {
  return __async(this, arguments, function* (form, optionsArg = {}) {
    const { sections = [] } = optionsArg;
    if (!confirmation.parentNode) {
      document.body.appendChild(confirmation);
    }
    let collectedResult = { type: "nochange" };
    const inputs = findAddressInputs(form);
    const structure = parseFormStructure(form);
    const listboxComponents = Array.from(document.querySelectorAll("mapbox-search-listbox"));
    for (const input of inputs) {
      if (sections.length) {
        const structureRef = structure.find((s) => s.input === input);
        if (!structureRef) {
          continue;
        }
        if (!sections.includes(structureRef.section)) {
          continue;
        }
      }
      const autofillValues = getFormAutofillValues(form, input);
      const listbox = listboxComponents.find((lb) => lb.input === input);
      if (listbox) {
        const lastRetrievedFeature = listbox.retrieveFeature;
        if (lastRetrievedFeature) {
          const snapshot = featureToAutofillValueMap(lastRetrievedFeature);
          if (!checkAutofillValuesChanged(autofillValues, snapshot)) {
            continue;
          }
        }
      }
      const accessToken = optionsArg.accessToken || config.accessToken;
      const result = yield confirmation.tryShow(autofillValues, __spreadProps(__spreadValues({}, optionsArg), {
        accessToken
      }));
      if (result.type === "change") {
        input.dataset["mapboxSuccess"] = "true";
        const suggestion = (0, import_search_js_core9.featureToSuggestion)(result.feature);
        setFormAutofillValues(form, input, suggestion);
        if (listbox) {
          listbox.retrieveFeature = result.feature;
        }
      }
      if (result.type === "change" && collectedResult.type !== "cancel") {
        collectedResult = result;
      }
      if (result.type === "cancel") {
        collectedResult = result;
      }
    }
    return collectedResult;
  });
}
module.exports = __toCommonJS(src_exports);
//# sourceMappingURL=index-development.js.map
